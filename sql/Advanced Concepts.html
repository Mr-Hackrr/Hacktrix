<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced SQL Concepts</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">
    <link rel="stylesheet" href="style.css"> <!-- Assuming your CSS file is named style.css -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <!-- Header Bar -->
    <header class="header-bar">
        <span class="brand-name">TechyVia</span>
        <nav class="navbar">
            <ul class="nav-links">
                <li><a href="about.html" class="nav-link">About</a></li>
                <li><a href="exercise.html" class="nav-link">Exercise</a></li>
                <li><a href="project.html" class="nav-link">Project</a></li>
                <li><a href="contact.html" class="nav-link">Contact Us</a></li>
            </ul>
        </nav>
        <div class="toggle-menu" id="toggle-menu" onclick="openNav()">☰</div>
    </header>

    <!-- Sidebar -->
    <div id="sideMenu" class="sideMenu" role="navigation" aria-label="Sidebar Navigation">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()" aria-label="Close sidebar">×</a>
        <nav class="sidebar-nav">
            <ul class="sidebar-links">
                <li class="sidebar-link"><a href="#window-functions" tabindex="0">Window Functions</a></li>
                <li class="sidebar-link"><a href="#ranking-functions" tabindex="0">Ranking Functions</a></li>
                <li class="sidebar-link"><a href="#aggregate-functions" tabindex="0">Aggregate Functions</a></li>
                <li class="sidebar-link"><a href="#value-functions" tabindex="0">Value Functions</a></li>
                <li class="sidebar-link"><a href="#common-table-expressions" tabindex="0">Common Table Expressions (CTEs)</a></li>
                <li class="sidebar-link"><a href="#recursive-queries" tabindex="0">Recursive Queries</a></li>
                <li class="sidebar-link"><a href="#regular-expressions" tabindex="0">Regular Expressions</a></li>
                <li class="sidebar-link"><a href="#denormalization-for-performance" tabindex="0">Denormalization for Performance</a></li>
                <li class="sidebar-link"><a href="#database-partitioning" tabindex="0">Database Partitioning</a></li>
                <li class="sidebar-link"><a href="#scaling-strategies" tabindex="0">Scaling Strategies (Horizontal vs. Vertical)</a></li>
                <li class="sidebar-link"><a href="#security-access-control" tabindex="0">Security and Access Control</a></li>
                <li class="sidebar-link"><a href="#user-roles-privileges" tabindex="0">User Roles and Privileges</a></li>
                <li class="sidebar-link"><a href="#encryption-methods" tabindex="0">Encryption Methods</a></li>
                <li class="sidebar-link"><a href="#auditing-logging" tabindex="0">Auditing and Logging</a></li>
                <li class="sidebar-link"><a href="#sql-performance-optimization" tabindex="0">SQL Performance Optimization</a></li>
                <li class="sidebar-link"><a href="#query-optimization" tabindex="0">Query Optimization Techniques</a></li>
                <li class="sidebar-link"><a href="#index-tuning" tabindex="0">Index Tuning</a></li>
                <li class="sidebar-link"><a href="#execution-plans" tabindex="0">Execution Plans</a></li>
                <li class="sidebar-link"><a href="#triggers" tabindex="0">Triggers in SQL</a></li>
                <li class="sidebar-link"><a href="#cursors" tabindex="0">Cursors in SQL</a></li>
                <li class="sidebar-link"><a href="#udfs" tabindex="0">User-Defined Functions (UDFs) in SQL</a></li>
                <li class="sidebar-link"><a href="#udts" tabindex="0">User-Defined Types (UDTs)</a></li>
                <li class="sidebar-link"><a href="#user-contributions" tabindex="0">Submit Your SQL Queries or Challenges</a></li>
            </ul>
        </nav>
    </div>

<!-- Content -->
<div id="content">
    <h1>Advanced SQL Concepts</h1>

    <section id="window-functions">
        <h2>Introduction to Window Functions</h2>
        <p>
            Window functions are a powerful tool for performing advanced data analysis and computations.
            Unlike standard aggregate functions, window functions do not collapse rows; instead, they provide results for each row in the dataset.
        </p>
    
        <h3>How Window Functions Work</h3>
        <p>
            Window functions operate over a "window" of rows, defined by the <code>OVER</code> clause. The <code>OVER</code> clause specifies how rows are partitioned and ordered within the window.
        </p>
        <ul>
            <li><strong>Function:</strong> The specific operation, such as <code>SUM</code>, <code>AVG</code>, <code>ROW_NUMBER</code>, etc.</li>
            <li><strong>PARTITION BY:</strong> Defines subsets of data (optional).</li>
            <li><strong>ORDER BY:</strong> Determines the order of rows within the window (optional).</li>
        </ul>
    
        <h3>Syntax</h3>
        <div class="code-box">
            <pre><code>
        function_name(expression) OVER (
        [PARTITION BY column1, column2, ...]
        [ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...]
        [frame_specification]
    )</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
    
        <h3>Types of Window Functions</h3>
        <ul>
            <li><strong>Ranking Functions:</strong> <code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code></li>
            <li><strong>Aggregate Functions:</strong> <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code>, <code>MAX()</code>, <code>COUNT()</code></li>
            <li><strong>Value Functions:</strong> <code>FIRST_VALUE()</code>, <code>LAST_VALUE()</code>, <code>NTH_VALUE()</code>, <code>LEAD()</code>, <code>LAG()</code></li>
        </ul>
    
        <h3>Examples</h3>
    
        <h4>Example 1: Calculating Running Totals</h4>
        <div class="code-box">
            <pre><code>
        SELECT
        CustomerID,
        Amount,
        SUM(Amount) OVER (PARTITION BY CustomerID ORDER BY SaleID) AS RunningTotal
    FROM Sales;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
    
        <h4>Example 2: Ranking Rows</h4>
        <div class="code-box">
            <pre><code>SELECT
        DepartmentID,
        EmployeeName,
        Salary,
        RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS Rank
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
    
        <h4>Example 3: Identifying Trends</h4>
        <div class="code-box">
            <pre><code>
        SELECT
        SaleID,
        SaleMonth,
        Amount,
        LAG(Amount) OVER (ORDER BY SaleMonth) AS PreviousMonthAmount
    FROM Sales;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
    
        <h3>Use Cases</h3>
        <ul>
            <li><strong>Cumulative Metrics:</strong> Calculate running totals, moving averages, or cumulative percentages.</li>
            <li><strong>Comparative Analysis:</strong> Compare a row to its previous or next row using <code>LEAD</code> and <code>LAG</code>.</li>
            <li><strong>Ranking:</strong> Assign ranks or dense ranks to rows within categories.</li>
            <li><strong>Highlighting Extremes:</strong> Identify first or last values in sorted subsets.</li>
        </ul>
    </section>

    <section id="ranking-functions">
        <h2> Ranking Functions</h2>
        <p>
            Ranking functions are used to assign ranks to rows within a partition of a result set. They are essential for analyzing trends, assigning positions, and grouping related information effectively.
        </p>
    
        <h3>Key Ranking Functions</h3>
        <ul>
            <li><strong>ROW_NUMBER():</strong> Assigns a unique number to each row within a partition.</li>
            <li><strong>RANK():</strong> Assigns a rank to each row, with gaps in ranks for ties.</li>
            <li><strong>DENSE_RANK():</strong> Similar to <code>RANK()</code>, but without gaps in ranks for ties.</li>
        </ul>
    
        <h3>Example Table</h3>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>EmployeeID</th>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>101</td>
                    <td>Alice</td>
                    <td>60000</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>102</td>
                    <td>Bob</td>
                    <td>55000</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>60000</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>102</td>
                    <td>David</td>
                    <td>52000</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>101</td>
                    <td>Eve</td>
                    <td>58000</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Examples</h3>
    
        <h4>Example 1: Using ROW_NUMBER()</h4>
        <p>Assign unique row numbers to employees based on their salaries:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        EmployeeID,
        EmployeeName,
        Salary,
        ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNumber
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>EmployeeID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                    <th>RowNumber</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>Alice</td>
                    <td>60000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Charlie</td>
                    <td>60000</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>Eve</td>
                    <td>58000</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Bob</td>
                    <td>55000</td>
                    <td>4</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>David</td>
                    <td>52000</td>
                    <td>5</td>
                </tr>
            </tbody>
        </table>
    
        <h4>Example 2: Using RANK()</h4>
        <p>Rank employees by their salaries within each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        EmployeeName,
        Salary,
        RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS Rank
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                    <th>Rank</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>Alice</td>
                    <td>60000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>60000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Eve</td>
                    <td>58000</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>Bob</td>
                    <td>55000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>David</td>
                    <td>52000</td>
                    <td>2</td>
                </tr>
            </tbody>
        </table>
    
        <h4>Example 3: Using DENSE_RANK()</h4>
        <p>Assign dense ranks to employees based on their salaries within each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        EmployeeName,
        Salary,
        DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS DenseRank
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                    <th>DenseRank</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>Alice</td>
                    <td>60000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>60000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Eve</td>
                    <td>58000</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>Bob</td>
                    <td>55000</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>David</td>
                    <td>52000</td>
                    <td>2</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="aggregate-functions">
        <h2>Aggregate Functions</h2>
        <p>
            Aggregate functions are used to perform calculations on a set of values and return a single value. These functions are essential for summarizing data and are commonly used in reporting and analytics.
        </p>
    
        <h3>Key Aggregate Functions</h3>
        <ul>
            <li><strong>SUM():</strong> Calculates the total sum of a numeric column.</li>
            <li><strong>AVG():</strong> Computes the average value of a numeric column.</li>
            <li><strong>MIN():</strong> Finds the smallest value in a column.</li>
            <li><strong>MAX():</strong> Finds the largest value in a column.</li>
            <li><strong>COUNT():</strong> Counts the number of rows or non-NULL values in a column.</li>
        </ul>
    
        <h3>Example Table</h3>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>60000</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>50000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>3</td>
                    <td>Charlie</td>
                    <td>70000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>4</td>
                    <td>David</td>
                    <td>55000</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>5</td>
                    <td>Eve</td>
                    <td>45000</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Examples</h3>
    
        <h4>1. Using SUM()</h4>
        <p>Calculate the total salary for each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        SUM(Salary) AS TotalSalary
    FROM Employees
    GROUP BY DepartmentID;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>TotalSalary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>110000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>125000</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>45000</td>
                </tr>
            </tbody>
        </table>
    
        <h4>2. Using AVG()</h4>
        <p>Calculate the average salary for each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        AVG(Salary) AS AverageSalary
    FROM Employees
    GROUP BY DepartmentID;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>AverageSalary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>55000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>62500</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>45000</td>
                </tr>
            </tbody>
        </table>
    
        <h4>3. Using MIN()</h4>
        <p>Find the lowest salary in each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        MIN(Salary) AS MinSalary
    FROM Employees
    GROUP BY DepartmentID;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>MinSalary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>50000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>55000</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>45000</td>
                </tr>
            </tbody>
        </table>
    
        <h4>4. Using MAX()</h4>
        <p>Find the highest salary in each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        MAX(Salary) AS MaxSalary
    FROM Employees
    GROUP BY DepartmentID;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>MaxSalary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>60000</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>70000</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>45000</td>
                </tr>
            </tbody>
        </table>
    
        <h4>5. Using COUNT()</h4>
        <p>Count the number of employees in each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        COUNT(EmployeeID) AS EmployeeCount
    FROM Employees
    GROUP BY DepartmentID;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i></button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeCount</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>103</td>
                    <td>1</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="value-functions">
        <h2>Value Functions</h2>
        <p>
            Value functions allow you to retrieve specific values from a dataset within a defined window. These functions are particularly useful for comparing rows, identifying trends, and performing advanced analytics.
        </p>
    
        <h3>Key Value Functions</h3>
        <ul>
            <li><strong>FIRST_VALUE():</strong> Retrieves the first value in a window.</li>
            <li><strong>LAST_VALUE():</strong> Retrieves the last value in a window.</li>
            <li><strong>NTH_VALUE():</strong> Retrieves the nth value in a window.</li>
            <li><strong>LEAD():</strong> Accesses subsequent rows relative to the current row.</li>
            <li><strong>LAG():</strong> Accesses preceding rows relative to the current row.</li>
        </ul>
    
        <h3>Example Table</h3>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>EmployeeID</th>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>Salary</th>
                    <th>HireDate</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>101</td>
                    <td>Alice</td>
                    <td>60000</td>
                    <td>2020-01-15</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>101</td>
                    <td>Bob</td>
                    <td>50000</td>
                    <td>2021-03-10</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>55000</td>
                    <td>2019-07-22</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>102</td>
                    <td>David</td>
                    <td>70000</td>
                    <td>2018-11-30</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>102</td>
                    <td>Eve</td>
                    <td>45000</td>
                    <td>2022-05-18</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Examples</h3>
    
        <h4>1. Using FIRST_VALUE()</h4>
        <p>Retrieve the first hired employee in each department based on hire date:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        EmployeeName,
        HireDate,
        FIRST_VALUE(EmployeeName) OVER (
            PARTITION BY DepartmentID ORDER BY HireDate
        ) AS FirstHired
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>HireDate</th>
                    <th>FirstHired</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>Alice</td>
                    <td>2020-01-15</td>
                    <td>Charlie</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Bob</td>
                    <td>2021-03-10</td>
                    <td>Charlie</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>2019-07-22</td>
                    <td>Charlie</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>David</td>
                    <td>2018-11-30</td>
                    <td>David</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>Eve</td>
                    <td>2022-05-18</td>
                    <td>David</td>
                </tr>
            </tbody>
        </table>
    
        <h4>2. Using LAST_VALUE()</h4>
        <p>Retrieve the last hired employee in each department:</p>
        <div class="code-box">
            <pre><code>
        SELECT
        DepartmentID,
        EmployeeName,
        HireDate,
        LAST_VALUE(EmployeeName) OVER (
            PARTITION BY DepartmentID ORDER BY HireDate ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS LastHired
    FROM Employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>DepartmentID</th>
                    <th>EmployeeName</th>
                    <th>HireDate</th>
                    <th>LastHired</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>101</td>
                    <td>Alice</td>
                    <td>2020-01-15</td>
                    <td>Bob</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Bob</td>
                    <td>2021-03-10</td>
                    <td>Bob</td>
                </tr>
                <tr>
                    <td>101</td>
                    <td>Charlie</td>
                    <td>2019-07-22</td>
                    <td>Bob</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>David</td>
                    <td>2018-11-30</td>
                    <td>Eve</td>
                </tr>
                <tr>
                    <td>102</td>
                    <td>Eve</td>
                    <td>2022-05-18</td>
                    <td>Eve</td>
                </tr>
            </tbody>
        </table>
        <h4>3. Using NTH_VALUE()</h4>
<p>Retrieve the second highest salary in each department:</p>
<div class="code-box">
    <pre><code>
    SELECT
    DepartmentID,
    EmployeeName,
    Salary,
    NTH_VALUE(Salary, 2) OVER (
        PARTITION BY DepartmentID ORDER BY Salary DESC
    ) AS SecondHighestSalary
FROM Employees;</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
</div>
<p><strong>Result:</strong></p>
<table class="data-table margin-lg">
    <thead>
        <tr>
            <th>DepartmentID</th>
            <th>EmployeeName</th>
            <th>Salary</th>
            <th>SecondHighestSalary</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>101</td>
            <td>Alice</td>
            <td>60000</td>
            <td>55000</td>
        </tr>
        <tr>
            <td>101</td>
            <td>Bob</td>
            <td>50000</td>
            <td>55000</td>
        </tr>
        <tr>
            <td>101</td>
            <td>Charlie</td>
            <td>55000</td>
            <td>55000</td>
        </tr>
        <tr>
            <td>102</td>
            <td>David</td>
            <td>70000</td>
            <td>45000</td>
        </tr>
        <tr>
            <td>102</td>
            <td>Eve</td>
            <td>45000</td>
            <td>45000</td>
        </tr>
    </tbody>
</table>

<h4>4. Using LEAD()</h4>
<p>Compare each employee's salary with the next employee's salary:</p>
<div class="code-box">
    <pre><code>
    SELECT
    EmployeeName,
    Salary,
    LEAD(Salary) OVER (ORDER BY Salary DESC) AS NextSalary
FROM Employees;</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
</div>
<p><strong>Result:</strong></p>
<table class="data-table margin-lg">
    <thead>
        <tr>
            <th>EmployeeName</th>
            <th>Salary</th>
            <th>NextSalary</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>David</td>
            <td>70000</td>
            <td>60000</td>
        </tr>
        <tr>
            <td>Alice</td>
            <td>60000</td>
            <td>55000</td>
        </tr>
        <tr>
            <td>Charlie</td>
            <td>55000</td>
            <td>50000</td>
        </tr>
        <tr>
            <td>Bob</td>
            <td>50000</td>
            <td>45000</td>
        </tr>
        <tr>
            <td>Eve</td>
            <td>45000</td>
            <td>NULL</td>
        </tr>
    </tbody>
</table>

<h4>5. Using LAG()</h4>
<p>Compare each employee's salary with the previous employee's salary:</p>
<div class="code-box">
    <pre><code>
    SELECT
    EmployeeName,
    Salary,
    LAG(Salary) OVER (ORDER BY Salary DESC) AS PreviousSalary
FROM Employees;</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
</div>
<p><strong>Result:</strong></p>
<table class="data-table margin-lg">
    <thead>
        <tr>
            <th>EmployeeName</th>
            <th>Salary</th>
            <th>PreviousSalary</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>David</td>
            <td>70000</td>
            <td>NULL</td>
        </tr>
        <tr>
            <td>Alice</td>
            <td>60000</td>
            <td>70000</td>
        </tr>
        <tr>
            <td>Charlie</td>
            <td>55000</td>
            <td>60000</td>
        </tr>
        <tr>
            <td>Bob</td>
            <td>50000</td>
            <td>55000</td>
        </tr>
        <tr>
            <td>Eve</td>
            <td>45000</td>
            <td>50000</td>
        </tr>
    </tbody>
</table>

    </section>

    <section id="common-table-expressions">
        <h2>2. Common Table Expressions (CTEs)</h2>
        <p>
            Common Table Expressions (CTEs) are temporary result sets that simplify complex queries. They allow you to structure your SQL queries in a modular and readable way. A CTE is defined using the <code>WITH</code> keyword and can be used in <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements.
        </p>
    
        <h3>Key Benefits of CTEs</h3>
        <ul>
            <li><strong>Improved Readability:</strong> Break down complex queries into smaller, logical parts.</li>
            <li><strong>Reusability:</strong> Use the CTE multiple times within the same query.</li>
            <li><strong>Recursive Queries:</strong> Handle hierarchical or iterative data more efficiently.</li>
        </ul>
    
        <h3>Syntax</h3>
        <div class="code-box">
            <pre><code>
        WITH cte_name (column1, column2, ...) AS (
        SELECT column1, column2, ...
        FROM table_name
        WHERE conditions
    )
    SELECT column1, column2, ...
    FROM cte_name;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Examples</h3>
    
        <h4>1. Aggregating Sales Data</h4>
        <p>Find all salespeople whose total sales exceed $10,000:</p>
        <div class="code-box">
            <pre><code>
        WITH Sales_CTE (SalesPerson, TotalSales) AS (
        SELECT SalesPerson, SUM(SalesAmount)
        FROM Sales
        GROUP BY SalesPerson
    )
    SELECT SalesPerson, TotalSales
    FROM Sales_CTE
    WHERE TotalSales > 10000;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The CTE <code>Sales_CTE</code> calculates the total sales for each salesperson. The main query filters out those with total sales greater than $10,000.</p>
    
        <h4>2. Using CTEs for Ranking</h4>
        <p>Rank employees by their salaries within each department:</p>
        <div class="code-box">
            <pre><code>
        WITH RankedEmployees AS (
        SELECT 
            DepartmentID, 
            EmployeeName, 
            Salary,
            RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS Rank
        FROM Employees
    )
    SELECT *
    FROM RankedEmployees
    WHERE Rank = 1;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The CTE <code>RankedEmployees</code> calculates the rank of employees within each department. The main query retrieves the top-ranked employee from each department.</p>
    
        <h4>3. Recursive CTE: Hierarchical Data</h4>
        <p>Find all employees and their reporting hierarchy:</p>
        <div class="code-box">
            <pre><code>
        WITH RECURSIVE EmployeeHierarchy AS (
        SELECT EmployeeID, ManagerID, EmployeeName
        FROM Employees
        WHERE ManagerID IS NULL
        UNION ALL
        SELECT e.EmployeeID, e.ManagerID, e.EmployeeName
        FROM Employees e
        INNER JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID
    )
    SELECT *
    FROM EmployeeHierarchy;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The recursive CTE <code>EmployeeHierarchy</code> builds a hierarchy of employees, starting from the top-level managers and iteratively adding their subordinates.</p>
    
        <h4>4. Joining CTEs</h4>
        <p>Combine data from multiple CTEs to calculate average sales per region:</p>
        <div class="code-box">
            <pre><code>
        WITH RegionalSales AS (
        SELECT Region, SUM(SalesAmount) AS TotalSales
        FROM Sales
        GROUP BY Region
    ),
    AverageSales AS (
        SELECT AVG(TotalSales) AS AvgSales
        FROM RegionalSales
    )
    SELECT Region, TotalSales, AvgSales
    FROM RegionalSales, AverageSales
    WHERE TotalSales > AvgSales;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The first CTE <code>RegionalSales</code> calculates total sales by region. The second CTE <code>AverageSales</code> computes the average sales across all regions. The main query filters regions with sales above the average.</p>
    
        <h3>Use Cases</h3>
        <ul>
            <li><strong>Data Aggregation:</strong> Simplify queries for calculating totals, averages, or other aggregates.</li>
            <li><strong>Hierarchical Data:</strong> Handle recursive relationships, such as organizational charts or category trees.</li>
            <li><strong>Query Modularity:</strong> Break down complex queries into manageable, reusable parts.</li>
            <li><strong>Temporary Data:</strong> Use CTEs for temporary data that doesn't need to be stored in the database.</li>
        </ul>
    </section>

    <section id="recursive-queries">
        <h2>3. Recursive Queries</h2>
        <p>
            Recursive queries in SQL are used to handle hierarchical or iterative data structures, such as organizational charts, file systems, or category trees. These queries use a combination of the <code>WITH RECURSIVE</code> clause and a recursive Common Table Expression (CTE) to achieve their functionality.
        </p>
    
        <h3>How Recursive Queries Work</h3>
        <ul>
            <li><strong>Base Query:</strong> The initial query retrieves the top-level rows, such as root nodes in a hierarchy.</li>
            <li><strong>Recursive Query:</strong> This query references the CTE itself to retrieve child nodes or related rows.</li>
            <li><strong>Termination:</strong> The recursion stops when no more rows match the conditions.</li>
        </ul>
    
        <h3>Syntax</h3>
        <div class="code-box">
            <pre><code>
        WITH RECURSIVE cte_name AS (
        base_query
        UNION ALL
        recursive_query
    )
    SELECT * FROM cte_name;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Examples</h3>
    
        <h4>1. Building an Employee Hierarchy</h4>
        <p>Retrieve a hierarchical structure of employees and their managers:</p>
        <div class="code-box">
            <pre><code>
        WITH RECURSIVE EmployeeHierarchy AS (
        SELECT employee_id, manager_id, employee_name
        FROM employees
        WHERE manager_id IS NULL
        UNION ALL
        SELECT e.employee_id, e.manager_id, e.employee_name
        FROM employees e
        INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.employee_id
    )
    SELECT * FROM EmployeeHierarchy;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The base query retrieves employees with no managers (top-level). The recursive query retrieves employees reporting to the previously retrieved rows, iteratively building the hierarchy.</p>
    
        <h4>2. Calculating Factorials</h4>
        <p>Calculate the factorial of numbers from 1 to 5:</p>
        <div class="code-box">
            <pre><code>
        WITH RECURSIVE FactorialCTE AS (
        SELECT 1 AS n, 1 AS factorial
        UNION ALL
        SELECT n + 1, factorial * (n + 1)
        FROM FactorialCTE
        WHERE n < 5
    )
    SELECT * FROM FactorialCTE;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The base query starts with <code>n = 1</code> and <code>factorial = 1</code>. The recursive query calculates the factorial by incrementing <code>n</code> and multiplying it with the previous factorial value.</p>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>n</th>
                    <th>factorial</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>6</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>24</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>120</td>
                </tr>
            </tbody>
        </table>
    
        <h4>3. Generating a Sequence</h4>
        <p>Create a sequence of numbers from 1 to 10:</p>
        <div class="code-box">
            <pre><code>
        WITH RECURSIVE SequenceCTE AS (
        SELECT 1 AS n
        UNION ALL
        SELECT n + 1
        FROM SequenceCTE
        WHERE n < 10
    )
    SELECT * FROM SequenceCTE;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The base query starts with <code>n = 1</code>. The recursive query increments <code>n</code> by 1 until it reaches 10.</p>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>n</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                </tr>
                <tr>
                    <td>2</td>
                </tr>
                <tr>
                    <td>3</td>
                </tr>
                <tr>
                    <td>4</td>
                </tr>
                <tr>
                    <td>5</td>
                </tr>
                <tr>
                    <td>6</td>
                </tr>
                <tr>
                    <td>7</td>
                </tr>
                <tr>
                    <td>8</td>
                </tr>
                <tr>
                    <td>9</td>
                </tr>
                <tr>
                    <td>10</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Use Cases</h3>
        <ul>
            <li><strong>Organizational Charts:</strong> Query hierarchical structures like employees and their managers.</li>
            <li><strong>Category Trees:</strong> Handle nested categories in e-commerce or content management systems.</li>
            <li><strong>Mathematical Calculations:</strong> Perform iterative calculations like factorials or sequences.</li>
            <li><strong>File Systems:</strong> Explore hierarchical file and folder structures.</li>
        </ul>
    </section>

    <section id="regular-expressions">
        <h2>Regular Expressions in SQL</h2>
        <p>
            <strong>Simple Explanation:</strong><br>
            Regular Expressions (RegEx) in SQL allow you to search, validate, or extract data using patterns. Think of RegEx as a powerful filter for text data, enabling complex matching beyond simple LIKE clauses. It is a versatile tool for cleaning and analyzing textual data.
        </p>

        <h3>Key Benefits of Regular Expressions</h3>
        <ul>
            <li><strong>Advanced Pattern Matching:</strong> Identify complex patterns in text data.</li>
            <li><strong>Data Validation:</strong> Ensure data adheres to specific formats, such as emails or phone numbers.</li>
            <li><strong>Text Extraction:</strong> Extract useful information from unstructured text.</li>
            <li><strong>Data Transformation:</strong> Replace or modify text patterns efficiently.</li>
        </ul>

        <h3>Comprehensive Examples</h3>

        <h4>1. Email Validation</h4>
        <p><strong>Scenario:</strong> Check if a string is a valid email address.<br>
        <strong>SQL Snippet (PostgreSQL):</strong></p>
        <div class="code-box">
            <pre><code>
        SELECT 'test@example.com' ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$' AS is_valid;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> This query checks if the input string matches the typical email format: <code>username@domain.extension</code>. The result will return <code>TRUE</code> if valid and <code>FALSE</code> otherwise.</p>
        <p><strong>Result:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>Input</th>
                    <th>IsValid</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>test@example.com</td>
                    <td>TRUE</td>
                </tr>
                <tr>
                    <td>invalid-email</td>
                    <td>FALSE</td>
                </tr>
            </tbody>
        </table>

        <h4>2. Extracting Numbers from Text</h4>
        <p><strong>Scenario:</strong> Pull out all numbers from a product description.<br>
        <strong>SQL Snippet (MySQL):</strong></p>
        <div class="code-box">
            <pre><code>SELECT REGEXP_SUBSTR('Product weighs 5kg and is 10cm tall', '[0-9]+') AS extracted_number;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> The query identifies the first number in the input string. To extract all numbers, modify the query to iterate over matches.</p>

        <h4>3. Common Regular Expression Patterns</h4>
        <p>The table below summarizes commonly used RegEx patterns and their descriptions:</p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>Pattern</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$</code></td>
                    <td>Matches a valid email address.</td>
                    <td>test@example.com</td>
                </tr>
                <tr>
                    <td><code>[0-9]+</code></td>
                    <td>Matches one or more digits.</td>
                    <td>12345</td>
                </tr>
                <tr>
                    <td><code>\b[A-Z]{3}\b</code></td>
                    <td>Matches three-letter uppercase words.</td>
                    <td>USA, CAT</td>
                </tr>
                <tr>
                    <td><code>\d{4}-\d{2}-\d{2}</code></td>
                    <td>Matches a date in YYYY-MM-DD format.</td>
                    <td>2023-01-01</td>
                </tr>
                <tr>
                    <td><code>^(?=.*[A-Z])(?=.*\d).{8,}$</code></td>
                    <td>Validates a strong password.</td>
                    <td>MyP@ssw0rd</td>
                </tr>
            </tbody>
        </table>

        <h3>Best Practices for Regular Expressions</h3>
        <ul>
            <li><strong>Keep Patterns Simple:</strong> Avoid overly complex patterns that are hard to maintain.</li>
            <li><strong>Test Your Patterns:</strong> Use online tools or database-specific testing environments to validate patterns before deploying them.</li>
            <li><strong>Monitor Performance:</strong> Use RegEx judiciously on large datasets to avoid performance bottlenecks.</li>
            <li><strong>Document Patterns:</strong> Include comments or documentation to explain the purpose of complex patterns.</li>
        </ul>

        <h3>Tips for Database Compatibility</h3>
        <p>Not all databases support RegEx natively. Here's a quick compatibility guide:</p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>Database</th>
                    <th>RegEx Support</th>
                    <th>Functions</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MySQL</td>
                    <td>Partial</td>
                    <td><code>REGEXP_LIKE</code>, <code>REGEXP_REPLACE</code></td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>Full</td>
                    <td><code>~</code>, <code>~*</code>, <code>REGEXP_REPLACE</code></td>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>Full</td>
                    <td><code>REGEXP_LIKE</code>, <code>REGEXP_SUBSTR</code>, <code>REGEXP_REPLACE</code></td>
                </tr>
                <tr>
                    <td>SQL Server</td>
                    <td>Limited</td>
                    <td>CLR Integration or <code>LIKE</code></td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="denormalization-for-performance">
        <h2>Denormalization for Performance</h2>
    
        <h3>Denormalization</h3>
        <p>
            <strong>Analogy:</strong> Imagine you're moving into a new house. If your furniture is compactly stored in boxes (like IKEA), it takes time to assemble everything after moving in. But if some pieces are pre-assembled, you can set up your home much faster, even if it takes up more space in the moving truck. Similarly:
        </p>
        <ul>
            <li><strong>Normalization:</strong> Data is broken into smaller, logical pieces to minimize redundancy and optimize storage.</li>
            <li><strong>Denormalization:</strong> Combines some of these pieces to improve performance by reducing the time needed to retrieve and process data.</li>
        </ul>
        <p>
            Denormalization is a strategic decision where you trade a bit of storage efficiency for faster query performance. It’s particularly useful in systems where read performance is critical, like dashboards or e-commerce websites.
        </p>
    
        <h3>When to Use Denormalization</h3>
        <ul>
            <li><strong>High Read Demand:</strong> When most operations involve reading data, and you need quick responses.</li>
            <li><strong>Complex Joins:</strong> When queries involve multiple joins that slow down performance.</li>
            <li><strong>Aggregated Data:</strong> When frequently accessed data requires heavy calculations or summarization.</li>
            <li><strong>Reporting:</strong> For analytical or reporting systems where read performance outweighs storage concerns.</li>
        </ul>
    
        <h3>Examples</h3>
    
        <h4>1. Combining Tables for Faster Access</h4>
        <p><strong>Scenario:</strong> Instead of joining <code>Orders</code> and <code>Customers</code> tables every time, store customer details in the <code>Orders</code> table.</p>
        <div class="code-box">
            <pre><code>
    -- Normalized Structure
    CREATE TABLE Customers (
        CustomerID INT PRIMARY KEY,
        Name VARCHAR(255),
        Email VARCHAR(255)
    );
    
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        CustomerID INT,
        OrderDate DATE,
        FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
    );
    
    -- Denormalized Structure
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        CustomerID INT,
        CustomerName VARCHAR(255),
        CustomerEmail VARCHAR(255),
        OrderDate DATE
    );</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> By storing customer details directly in the <code>Orders</code> table, you avoid frequent joins between <code>Customers</code> and <code>Orders</code>, improving read performance.</p>
    
        <h4>2. Pre-Calculated Totals</h4>
        <p><strong>Scenario:</strong> Instead of calculating the total amount for each order every time, store the pre-calculated total in the database.</p>
        <div class="code-box">
            <pre><code>
    -- Normalized Structure
    CREATE TABLE OrderDetails (
        OrderID INT,
        ProductID INT,
        Quantity INT,
        Price DECIMAL(10, 2)
    );
    
    -- Denormalized Structure
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        TotalAmount DECIMAL(10, 2)
    );</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> Pre-calculating the total amount and storing it in the <code>Orders</code> table reduces the need for summing up order details during every query.</p>
    
        <h4>3. Adding Redundant Data for Aggregates</h4>
        <p><strong>Scenario:</strong> Add a column to store the total number of orders for each customer:</p>
        <div class="code-box">
            <pre><code>
    -- Normalized Structure
    SELECT CustomerID, COUNT(*) AS OrderCount
    FROM Orders
    GROUP BY CustomerID;
    
    -- Denormalized Structure
    ALTER TABLE Customers ADD COLUMN TotalOrders INT;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Explanation:</strong> Storing the total number of orders in the <code>Customers</code> table eliminates the need for frequent group-by queries.</p>
    
        <h3>Advantages of Denormalization</h3>
        <ul>
            <li><strong>Faster Reads:</strong> Reduces the need for complex joins and calculations during query execution.</li>
            <li><strong>Simplified Queries:</strong> Queries become more straightforward and easier to write.</li>
            <li><strong>Improved Reporting:</strong> Pre-aggregated data speeds up dashboards and reports.</li>
        </ul>
    
        <h3>Disadvantages of Denormalization</h3>
        <ul>
            <li><strong>Increased Storage:</strong> Redundant data consumes more space.</li>
            <li><strong>Data Inconsistency Risks:</strong> Updating redundant data requires additional effort to maintain consistency.</li>
            <li><strong>Complex Updates:</strong> More complex logic is needed to ensure changes propagate correctly.</li>
        </ul>
    
        <h3>Tips for Using Denormalization Effectively</h3>
        <ul>
            <li><strong>Analyze Use Cases:</strong> Only denormalize where performance gains justify the trade-offs.</li>
            <li><strong>Use Triggers:</strong> Automate updates to redundant data using database triggers.</li>
            <li><strong>Monitor Storage:</strong> Keep track of storage growth to ensure scalability.</li>
            <li><strong>Regular Audits:</strong> Periodically review your database to identify and address any inconsistencies.</li>
        </ul>
    
        <h3>Real-World Use Cases</h3>
        <ul>
            <li><strong>E-commerce:</strong> Store product categories directly in the product table for faster category-based searches.</li>
            <li><strong>Analytics:</strong> Pre-calculate and store aggregated metrics like monthly sales or active users.</li>
            <li><strong>Social Media:</strong> Cache user stats (e.g., followers count) for quick profile rendering.</li>
        </ul>
    
        <h3>Easy Takeaway</h3>
        <p>
            Denormalization is like pre-assembling furniture: it saves time during use but requires more effort to maintain. Use it strategically for read-heavy applications where performance is a priority, but always balance the trade-offs with storage and consistency.
        </p>
    </section>
    
    <section id="database-partitioning">
        <h2>Database Partitioning</h2>
        <h3>Database Partitioning</h3>
        <p>
            <strong>Analogy:</strong> Imagine a massive filing cabinet filled with documents. Searching for a single file could take ages. By dividing the cabinet into smaller sections labeled by criteria like date or client type, you can find what you need much faster.
        </p>
        <ul>
            <li><strong>Horizontal Partitioning:</strong> Splits rows across multiple tables. Example: A table of orders divided by region (e.g., North, South).</li>
            <li><strong>Vertical Partitioning:</strong> Splits columns across multiple tables. Example: Separating sensitive user details like passwords into a secure table.</li>
        </ul>
        <h3>Benefits</h3>
        <ul>
            <li><strong>Improved Query Performance:</strong> Access only the relevant partition instead of scanning the entire database.</li>
            <li><strong>Easier Maintenance:</strong> Smaller partitions are easier to back up and manage.</li>
            <li><strong>Scalability:</strong> Distribute partitions across multiple servers for load balancing.</li>
        </ul>
        <h3>Example: Horizontal Partitioning</h3>
        <p>Divide a large <code>Orders</code> table by regions:</p>
        <div class="code-box">
            <pre><code>
    -- Partitioned Tables
    CREATE TABLE Orders_North (...);
    CREATE TABLE Orders_South (...);
    
    -- Querying North Region Orders
    SELECT * FROM Orders_North WHERE OrderDate >= '2023-01-01';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Takeaway:</strong> Instead of scanning a massive <code>Orders</code> table, queries target only the relevant partition, speeding up data retrieval.</p>
    </section>
    
    <section id="scaling-strategies">
        <h2>Horizontal vs. Vertical Scaling</h2>
        <h3>Scaling Strategies</h3>
        <p>
            <strong>Analogy:</strong> Scaling your website is like expanding a restaurant:
            <ul>
                <li><strong>Vertical Scaling (Scale Up):</strong> Upgrade the kitchen with larger ovens and more staff in the same restaurant location.</li>
                <li><strong>Horizontal Scaling (Scale Out):</strong> Open additional restaurant branches, each with its own kitchen and staff.</li>
            </ul>
        </p>
        <h3>Vertical Scaling</h3>
        <ul>
            <li><strong>How It Works:</strong> Increase the capacity of a single server by adding more CPU, RAM, or storage.</li>
            <li><strong>Advantages:</strong> Simpler to implement and manage.</li>
            <li><strong>Disadvantages:</strong> Limited by hardware capacity and can be costly for high-end upgrades.</li>
        </ul>
        <h3>Horizontal Scaling</h3>
        <ul>
            <li><strong>How It Works:</strong> Add more servers to distribute the workload.</li>
            <li><strong>Advantages:</strong> Offers better redundancy, scalability, and fault tolerance.</li>
            <li><strong>Disadvantages:</strong> More complex to implement, requiring load balancers and data synchronization.</li>
        </ul>
        <h3>Example: Scaling a Website</h3>
        <div class="code-box">
            <pre><code>
    -- Vertical Scaling: Upgrading server resources
    ServerConfig {
        CPU: "8 cores",
        RAM: "32GB",
        Storage: "2TB"
    }
    
    -- Horizontal Scaling: Adding more servers
    LoadBalancer -> [Server1, Server2, Server3]</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Takeaway:</strong> Use vertical scaling for quick fixes and manageable growth. Opt for horizontal scaling when expecting significant traffic spikes or long-term growth.</p>
    </section>
    
    <section id="security-access-control">
        <h2>Security and Access Control</h2>
        <h3>Security and Access Control</h3>
        <p>
            <strong>Analogy:</strong> Imagine a high-end jewelry store:
            <ul>
                <li><strong>Security:</strong> Prevent break-ins with strong locks, alarms, and cameras.</li>
                <li><strong>Access Control:</strong> Ensure only authorized personnel can enter certain areas, like the vault.</li>
            </ul>
        </p>
        <h3>Key Components</h3>
        <ul>
            <li><strong>Authentication:</strong> Verify the identity of users (e.g., username and password).</li>
            <li><strong>Authorization:</strong> Control what actions authenticated users can perform.</li>
            <li><strong>Encryption:</strong> Protect data in transit and at rest to prevent unauthorized access.</li>
            <li><strong>Monitoring:</strong> Use tools like intrusion detection systems (IDS) to identify and respond to threats.</li>
        </ul>
        <h3>Example: Implementing Role-Based Access Control</h3>
        <div class="code-box">
            <pre><code>
    -- Creating Roles
    CREATE ROLE Admin;
    CREATE ROLE User;
    
    -- Granting Permissions
    GRANT SELECT, INSERT, UPDATE ON Products TO Admin;
    GRANT SELECT ON Products TO User;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <h3>Tips for Enhancing Security</h3>
        <ul>
            <li><strong>Use Strong Passwords:</strong> Enforce complexity and regular updates.</li>
            <li><strong>Enable Multi-Factor Authentication (MFA):</strong> Add an extra layer of security.</li>
            <li><strong>Encrypt Sensitive Data:</strong> Use SSL/TLS for data in transit and AES for data at rest.</li>
            <li><strong>Audit Logs Regularly:</strong> Track access and changes to identify potential threats.</li>
        </ul>
        <p><strong>Takeaway:</strong> Protect your website like a jewelry store—secure the data (goods) and ensure only authorized users (employees) have the right level of access.</p>
    </section>

    <section id="user-roles-privileges">
        <h2>User Roles and Privileges</h2>
        <h3>User Roles and Privileges</h3>
        <p>
            <strong>Analogy:</strong> Imagine a restaurant kitchen:
            <ul>
                <li><strong>User Roles:</strong> Different positions like Chef, Sous Chef, and Dishwasher, each with specific tasks.</li>
                <li><strong>Privileges:</strong> Assigning access to tools and areas based on their role. For instance, only the Chef can modify the menu, while the Line Cook executes recipes.</li>
            </ul>
        </p>
        <h3>Benefits of Role-Based Access Control (RBAC)</h3>
        <ul>
            <li><strong>Enhanced Security:</strong> Limits user access to sensitive data and functionality.</li>
            <li><strong>Simplified Management:</strong> Easy to assign and revoke permissions by role rather than individual users.</li>
            <li><strong>Reduced Errors:</strong> Minimizes accidental or unauthorized changes.</li>
        </ul>
        <h3>Example: Implementing Roles and Privileges</h3>
        <div class="code-box">
            <pre><code>
    -- Creating Roles
    CREATE ROLE Admin;
    CREATE ROLE Moderator;
    CREATE ROLE User;
    
    -- Assigning Privileges
    GRANT ALL PRIVILEGES ON database_name.* TO 'Admin';
    GRANT SELECT, UPDATE ON database_name.* TO 'Moderator';
    GRANT SELECT ON database_name.* TO 'User';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <h3>Example Role Privileges</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Role</th>
                    <th>Privileges</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Admin</td>
                    <td>Create, Edit, Delete, View</td>
                </tr>
                <tr>
                    <td>Moderator</td>
                    <td>Edit, View</td>
                </tr>
                <tr>
                    <td>User</td>
                    <td>View</td>
                </tr>
                <tr>
                    <td>Guest</td>
                    <td>Limited View</td>
                </tr>
            </tbody>
        </table>
        <h3>Takeaway</h3>
        <p>
            Assign roles and privileges based on the principle of least privilege—users should have only the permissions they need to perform their tasks. This enhances security and reduces risks.
        </p>
    </section>
    
    <section id="encryption-methods">
        <h2>Encryption Methods</h2>
        <h3>Encryption</h3>
        <p>
            <strong>Analogy:</strong> Think of sending sensitive letters:
            <ul>
                <li><strong>Encryption:</strong> Transforming the letter into an unreadable code (ciphertext) that only the recipient with the key can decode.</li>
            </ul>
        </p>
        <h3>Common Encryption Methods</h3>
        <ul>
            <li><strong>HTTPS (SSL/TLS):</strong> Ensures secure data transmission between the client and server.</li>
            <li><strong>Hashing (e.g., bcrypt):</strong> Protects stored passwords by converting them into a fixed-length code.</li>
            <li><strong>Symmetric Encryption (e.g., AES):</strong> Encrypts sensitive data stored on servers.</li>
        </ul>
        <h3>Example: Encrypting Sensitive Data</h3>
        <div class="code-box">
            <pre><code>
    -- Encrypting Passwords (PostgreSQL Example)
    INSERT INTO users (username, password)
    VALUES ('user1', crypt('password123', gen_salt('bf')));
    
    -- Using HTTPS (Nginx Example)
    server {
        listen 443 ssl;
        ssl_certificate /path/to/certificate.crt;
        ssl_certificate_key /path/to/private.key;
    }</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <h3>Takeaway</h3>
        <p>
            Encryption is essential for protecting sensitive data in transit and at rest. Use HTTPS for secure communication, hashing for password storage, and symmetric encryption for sensitive stored data.
        </p>
    </section>
    
    <section id="auditing-logging">
        <h2>Auditing and Logging</h2>
        <h3>Auditing and Logging</h3>
        <p>
            <strong>Analogy:</strong> A store's security system:
            <ul>
                <li><strong>Auditing:</strong> Reviewing security footage to detect potential issues or threats.</li>
                <li><strong>Logging:</strong> Keeping detailed records of transactions and events for future analysis.</li>
            </ul>
        </p>
        <h3>Benefits</h3>
        <ul>
            <li><strong>Enhanced Security:</strong> Detect unauthorized access and suspicious activity.</li>
            <li><strong>Forensic Analysis:</strong> Investigate incidents and identify vulnerabilities.</li>
            <li><strong>Compliance:</strong> Meet legal and regulatory requirements for data protection.</li>
        </ul>
        <h3>Example: Setting Up Logging</h3>
        <div class="code-box">
            <pre><code>
    -- Enabling General Query Log (MySQL)
    SET GLOBAL general_log = 'ON';
    SET GLOBAL log_output = 'TABLE';
    
    -- Viewing Logs
    SELECT * FROM mysql.general_log;
    
    -- Creating Audit Triggers
    CREATE TRIGGER audit_log_trigger
    AFTER INSERT ON sensitive_table
    FOR EACH ROW
    INSERT INTO audit_log (action, user, timestamp)
    VALUES ('INSERT', CURRENT_USER(), NOW());</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <h3>Takeaway</h3>
        <p>
            Regularly audit and log system activities to enhance security, meet compliance requirements, and maintain a robust defense against potential threats.
        </p>
    </section>
    
    <section id="sql-performance-optimization">
        <h2>SQL Performance Optimization</h2>
        <p>
            SQL performance optimization is the process of improving the efficiency of SQL queries and database operations. It focuses on reducing query execution time, lowering resource usage, and enhancing overall database performance.
        </p>
    
        <h3>Why Is Optimization Important?</h3>
        <ul>
            <li><strong>Faster Queries:</strong> Ensures minimal waiting time for users.</li>
            <li><strong>Efficient Resource Use:</strong> Reduces server CPU, memory, and disk usage.</li>
            <li><strong>Scalability:</strong> Handles large datasets and high traffic smoothly.</li>
            <li><strong>Cost Savings:</strong> Reduces infrastructure costs by optimizing hardware utilization.</li>
        </ul>
    
        <h3>Basics of SQL Optimization</h3>
        <h4>1. Understand the Query Lifecycle</h4>
        <p>When you execute a query, SQL goes through these steps:</p>
        <ul>
            <li><strong>Parsing:</strong> Validates the syntax.</li>
            <li><strong>Optimization:</strong> Creates the most efficient execution plan.</li>
            <li><strong>Execution:</strong> Runs the query based on the execution plan.</li>
        </ul>
    
        <h4>2. Common Factors Affecting Query Performance</h4>
        <ul>
            <li>Complex joins or subqueries.</li>
            <li>Missing or inefficient indexing.</li>
            <li>Large table scans.</li>
            <li>Redundant or repetitive queries.</li>
            <li>Poorly written logic (e.g., unnecessary calculations).</li>
        </ul>
    
        <h3>Beginner Optimization Techniques</h3>
        <h4>1. Select Only Required Columns</h4>
        <p>Avoid using <code>SELECT *</code> because it retrieves all columns, even those not needed.</p>
        <div class="code-box">
            <pre><code>
    -- Inefficient
    SELECT * FROM employees;
    
    -- Optimized
    SELECT emp_id, name FROM employees;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>2. Use WHERE Clauses</h4>
        <p>Filter rows using <code>WHERE</code> to minimize the data processed.</p>
        <div class="code-box">
            <pre><code>
    -- Without WHERE clause
    SELECT name FROM employees;
    
    -- With WHERE clause
    SELECT name FROM employees WHERE department = 'Sales';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>3. Avoid Redundant Calculations</h4>
        <p>Perform calculations once and reuse the result.</p>
        <div class="code-box">
            <pre><code>
    -- Inefficient
    SELECT emp_id, salary * 12 AS annual_salary FROM employees;
    
    -- Efficient
    WITH calculated_salaries AS (
        SELECT emp_id, salary * 12 AS annual_salary FROM employees
    )
    SELECT * FROM calculated_salaries;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>4. Use LIMIT for Pagination</h4>
        <p>When displaying limited results, use <code>LIMIT</code> (or <code>TOP</code> in SQL Server) to avoid fetching all rows.</p>
        <div class="code-box">
            <pre><code>SELECT * FROM employees LIMIT 10;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Intermediate Optimization Techniques</h3>
        <h4>5. Indexing</h4>
        <p><strong>What Is an Index?</strong> An index is a data structure that speeds up data retrieval operations. It works like a book's table of contents.</p>
        <p><strong>When to Use Indexes:</strong> Frequently searched columns, columns used in <code>WHERE</code>, <code>JOIN</code>, <code>GROUP BY</code>, and <code>ORDER BY</code>.</p>
        <div class="code-box">
            <pre><code>
    -- Create an Index
    CREATE INDEX idx_department ON employees(department);
    
    -- Query Before Indexing
    SELECT * FROM employees WHERE department = 'Sales';
    
    -- Query After Indexing
    SELECT * FROM employees WHERE department = 'Sales';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>6. Avoid Using Functions on Indexed Columns</h4>
        <p>Functions on indexed columns disable the index.</p>
        <div class="code-box">
            <pre><code>
    -- Inefficient
    SELECT * FROM employees WHERE UPPER(name) = 'ALICE';
    
    -- Efficient
    SELECT * FROM employees WHERE name = 'Alice';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>7. Optimize Joins</h4>
        <p>Use appropriate join types and ensure columns used in joins are indexed.</p>
        <div class="code-box">
            <pre><code>SELECT e.name, d.dept_name
    FROM employees e
    INNER JOIN departments d ON e.dept_id = d.dept_id;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>8. Reduce Subquery Use</h4>
        <p>Replace subqueries with joins for better performance.</p>
        <div class="code-box">
            <pre><code>
    -- Subquery
    SELECT name
    FROM employees
    WHERE dept_id = (SELECT dept_id FROM departments WHERE dept_name = 'Sales');
    
    -- Join
    SELECT e.name
    FROM employees e
    INNER JOIN departments d ON e.dept_id = d.dept_id
    WHERE d.dept_name = 'Sales';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Advanced Optimization Techniques</h3>
        <h4>9. Partitioning</h4>
        <p><strong>What Is Partitioning?</strong> Partitioning splits a large table into smaller, more manageable pieces, improving query performance.</p>
        <div class="code-box">
            <pre><code>-- Range Partitioning
    CREATE TABLE orders (
        order_id INT,
        order_date DATE,
        amount DECIMAL
    ) PARTITION BY RANGE (YEAR(order_date)) (
        PARTITION p2022 VALUES LESS THAN (2023),
        PARTITION p2023 VALUES LESS THAN (2024)
    );</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>10. Use Query Execution Plans</h4>
        <p>Execution plans show how SQL will process your query. Use <code>EXPLAIN</code> or similar commands to analyze queries.</p>
    
        <h4>11. Optimize Updates and Deletes</h4>
        <p>Perform batch updates or deletes instead of processing all rows at once.</p>
        <div class="code-box">
            <pre><code>
    -- Batch Update
    UPDATE employees
    SET salary = salary * 1.10
    WHERE department = 'Sales'
    LIMIT 100;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>12. Use Materialized Views</h4>
        <p>A materialized view stores query results for faster access.</p>
        <div class="code-box">
            <pre><code>
    CREATE MATERIALIZED VIEW sales_summary AS
    SELECT department, SUM(sales) AS total_sales
    FROM sales
    GROUP BY department;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Best Practices</h3>
        <ul>
            <li><strong>Write Simple Queries:</strong> Avoid overly complex logic.</li>
            <li><strong>Analyze and Monitor:</strong> Regularly check query performance using execution plans.</li>
            <li><strong>Index Wisely:</strong> Over-indexing can slow down writes.</li>
            <li><strong>Avoid Overfetching:</strong> Fetch only necessary data.</li>
            <li><strong>Archive Old Data:</strong> Move historical data to separate tables or databases.</li>
        </ul>
    </section>    

    <section id="query-optimization">
        <h2>Query Optimization Techniques</h2>
        <h3>Query Optimization</h3>
        <p>
            <strong>Analogy:</strong> Think of query optimization as finding the quickest route to a destination:
            <ul>
                <li><strong>Simplify Queries:</strong> Avoid unnecessary detours by removing redundant operations.</li>
                <li><strong>Use Efficient Data Types:</strong> Choose the most suitable "vehicle" (data type) for your data.</li>
                <li><strong>Limit Result Sets:</strong> Carry only what you need to minimize load.</li>
                <li><strong>Avoid SELECT *:</strong> Specify exactly what you're retrieving to save time and resources.</li>
            </ul>
        </p>
    
        <h3>Key Techniques for Query Optimization</h3>
        <ul>
            <li><strong>Indexing:</strong> Use indexes to speed up searches on large datasets.</li>
            <li><strong>Query Simplification:</strong> Rewrite complex queries to use joins instead of subqueries.</li>
            <li><strong>Partitioning:</strong> Split large tables into smaller, more manageable partitions.</li>
            <li><strong>Query Execution Plan:</strong> Analyze execution plans to identify bottlenecks.</li>
            <li><strong>Caching:</strong> Use caching to store frequently accessed data.</li>
        </ul>
    
        <h3>Examples and Best Practices</h3>
    
        <h4>1. Use Indexes Wisely</h4>
        <p>Indexes help databases find data quickly. Here's an example of a query with and without an index:</p>
        <div class="code-box">
            <pre><code>
    -- Without Index
    SELECT * FROM orders WHERE customer_id = 123;
    
    -- With Index
    CREATE INDEX idx_customer_id ON orders(customer_id);
    SELECT * FROM orders WHERE customer_id = 123;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Tip:</strong> Avoid creating too many indexes, as they can slow down insert, update, and delete operations.</p>
    
        <h4>2. Simplify Complex Queries</h4>
        <p>Rewrite queries to reduce complexity. For example:</p>
        <div class="code-box">
            <pre><code>
    -- Complex Query with Subquery
    SELECT * FROM orders
    WHERE customer_id IN (SELECT customer_id FROM customers WHERE region = 'West');
    
    -- Simplified Query with Join
    SELECT orders.*
    FROM orders
    JOIN customers ON orders.customer_id = customers.customer_id
    WHERE customers.region = 'West';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>3. Avoid SELECT *</h4>
        <p>Retrieve only the columns you need to reduce data transfer:</p>
        <div class="code-box">
            <pre><code>
    -- Inefficient Query
    SELECT * FROM orders WHERE status = 'Shipped';
    
    -- Optimized Query
    SELECT order_id, customer_id, status
    FROM orders
    WHERE status = 'Shipped';</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>4. Use LIMIT and OFFSET</h4>
        <p>Limit the number of rows retrieved to improve performance:</p>
        <div class="code-box">
            <pre><code>
    -- Retrieve the first 10 rows
    SELECT * FROM orders LIMIT 10;
    
    -- Retrieve the next 10 rows
    SELECT * FROM orders LIMIT 10 OFFSET 10;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>5. Analyze Query Execution Plans</h4>
        <p>Execution plans provide insight into how a query is executed. Use it to identify bottlenecks:</p>
        <div class="code-box">
            <pre><code>
    -- MySQL Example
    EXPLAIN SELECT * FROM orders WHERE customer_id = 123;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Advanced Optimization Techniques</h3>
        <ul>
            <li><strong>Partitioning:</strong> Divide large tables into smaller partitions to improve query performance.</li>
            <li><strong>Denormalization:</strong> Store pre-aggregated or redundant data for faster access.</li>
            <li><strong>Materialized Views:</strong> Use precomputed views for expensive queries.</li>
            <li><strong>Database Configuration:</strong> Tune database parameters like buffer size and query cache size.</li>
        </ul>
    
        <h3>Benefits of Query Optimization</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Technique</th>
                    <th>Example</th>
                    <th>Benefit</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Indexing</td>
                    <td>CREATE INDEX idx_column ON table(column);</td>
                    <td>Speeds up data retrieval</td>
                </tr>
                <tr>
                    <td>Partitioning</td>
                    <td>Partition data by region or date</td>
                    <td>Improves query performance on large tables</td>
                </tr>
                <tr>
                    <td>Execution Plan Analysis</td>
                    <td>EXPLAIN SELECT * FROM table;</td>
                    <td>Identifies performance bottlenecks</td>
                </tr>
                <tr>
                    <td>Caching</td>
                    <td>Store results of frequent queries</td>
                    <td>Reduces load on the database</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Key Takeaways</h3>
        <ul>
            <li>Optimize queries for both performance and readability.</li>
            <li>Use indexing, partitioning, and caching effectively.</li>
            <li>Regularly analyze execution plans to refine queries.</li>
            <li>Adopt advanced techniques like denormalization and materialized views for large-scale systems.</li>
        </ul>
    </section>
    
    <section id="index-tuning">
        <h2>Index Tuning</h2>
        <h3>Index Tuning</h3>
        <p>
            <strong>Analogy:</strong> Optimizing a library's catalog system to quickly locate books:
            <ul>
                <li><strong>Create Indexes:</strong> Add shortcuts to frequently searched shelves.</li>
                <li><strong>Monitor Index Usage:</strong> Remove unnecessary shortcuts.</li>
                <li><strong>Maintain Indexes:</strong> Regularly update to ensure efficiency.</li>
            </ul>
        </p>
        <h3>Example: Creating and Maintaining Indexes</h3>
        <div class="code-box">
            <pre><code>
    -- Creating an Index
    CREATE INDEX idx_status ON orders (status);
    
    -- Dropping Unused Index
    DROP INDEX idx_unused ON orders;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    </section>
    
    <section id="execution-plans">
        <h2>Execution Plans</h2>
        <h3>Execution Plans</h3>
        <p>
            <strong>Analogy:</strong> Decoding a GPS route to understand how to reach your destination:
            <ul>
                <li><strong>Operators:</strong> Steps like Table Scan or Index Seek.</li>
                <li><strong>Cost Estimates:</strong> Predicting the effort (CPU, I/O) required.</li>
                <li><strong>Data Flow:</strong> How data is joined, filtered, and aggregated.</li>
            </ul>
        </p>
        <h3>Example: Analyzing an Execution Plan</h3>
        <div class="code-box">
            <pre><code>
    -- Viewing Execution Plan (MySQL)
    EXPLAIN SELECT * FROM orders WHERE status = 'Shipped';
    
    -- Sample Output
    +----+-------------+--------+-------+---------------+------+---------+------+-------+
    | id | select_type | table  | type  | possible_keys | key  | key_len | ref  | rows  |
    +----+-------------+--------+-------+---------------+------+---------+------+-------+</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <h3>Takeaway</h3>
        <p>
            Use execution plans to identify inefficiencies like table scans. Focus on optimizing high-cost operations and ensure indexes are effectively utilized.
        </p>
    </section>

    <section id="triggers">
        <h2>Triggers in SQL</h2>
        <p>
            A trigger in SQL is a special kind of stored procedure that automatically executes in response to specific events on a table or a view. These events can be <strong>INSERT</strong>, <strong>UPDATE</strong>, or <strong>DELETE</strong> operations.
        </p>
        <p>
            Think of triggers as event-driven mechanisms that enforce business rules, automate tasks, or maintain data consistency without the need for manual intervention.
        </p>
    
        <h3>Beginner's Guide: How Triggers Work</h3>
        <ul>
            <li><strong>Basic Definition:</strong> Triggers are attached to tables or views and activated when a specified event occurs. They execute pre-defined logic written in SQL.</li>
            <li><strong>Why Use Triggers?</strong></li>
            <ul>
                <li>To enforce business rules.</li>
                <li>To automatically log changes in a table.</li>
                <li>To maintain audit trails.</li>
                <li>To validate data before insertion or update.</li>
            </ul>
        </ul>
    
        <h3>Trigger Syntax</h3>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER trigger_name
    { BEFORE | AFTER }
    { INSERT | UPDATE | DELETE }
    ON table_name
    FOR EACH ROW
    BEGIN
        -- SQL statements to execute
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Beginner Example: Logging Changes</h3>
        <p>
            Suppose you have a <code>users</code> table, and you want to log every new user added to an <code>audit_log</code> table.
        </p>
    
        <h4>Step 1: Create Tables</h4>
        <div class="code-box">
            <pre><code>
    -- Main table
    CREATE TABLE users (
        user_id INT PRIMARY KEY,
        name VARCHAR(100),
        email VARCHAR(100)
    );
    
    -- Audit log table
    CREATE TABLE audit_log (
        log_id INT AUTO_INCREMENT PRIMARY KEY,
        action VARCHAR(50),
        user_id INT,
        timestamp DATETIME
    );</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>Step 2: Create a Trigger</h4>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER after_user_insert
    AFTER INSERT ON users
    FOR EACH ROW
    BEGIN
        INSERT INTO audit_log (action, user_id, timestamp)
        VALUES ('User Added', NEW.user_id, NOW());
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>Step 3: Test the Trigger</h4>
        <div class="code-box">
            <pre><code>
    -- Insert a new user
    INSERT INTO users (user_id, name, email) VALUES (1, 'Alice', 'alice@example.com');
    
    -- Check the audit_log table
    SELECT * FROM audit_log;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>Output:</h4>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>log_id</th>
                    <th>action</th>
                    <th>user_id</th>
                    <th>timestamp</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>User Added</td>
                    <td>1</td>
                    <td>2025-01-15 10:00:00</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Intermediate Level: Types of Triggers</h3>
        <h4>1. BEFORE Triggers</h4>
        <p>Executed before the event (INSERT, UPDATE, DELETE). Useful for data validation.</p>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER before_salary_insert
    BEFORE INSERT ON employees
    FOR EACH ROW
    BEGIN
        IF NEW.salary < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Salary cannot be negative';
        END IF;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>2. AFTER Triggers</h4>
        <p>Executed after the event. Used for logging or updating other tables.</p>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER after_employee_delete
    AFTER DELETE ON employees
    FOR EACH ROW
    BEGIN
        INSERT INTO employee_archive (emp_id, name, deleted_at)
        VALUES (OLD.emp_id, OLD.name, NOW());
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>3. INSTEAD OF Triggers</h4>
        <p>Executed instead of the triggering event. Useful for views (supported in some databases like SQL Server).</p>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER instead_of_view_update
    INSTEAD OF UPDATE ON employee_view
    FOR EACH ROW
    BEGIN
        UPDATE employees
        SET name = NEW.name
        WHERE emp_id = OLD.emp_id;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Advanced Topics: Trigger Concepts and Optimization</h3>
        <h4>Accessing OLD and NEW Data</h4>
        <p>
            <strong>OLD:</strong> Refers to the row's values before the operation (for UPDATE or DELETE).<br>
            <strong>NEW:</strong> Refers to the row's values after the operation (for INSERT or UPDATE).
        </p>
        <div class="code-box">
            <pre><code>
    CREATE TRIGGER after_salary_update
    AFTER UPDATE ON employees
    FOR EACH ROW
    BEGIN
        INSERT INTO salary_log (emp_id, old_salary, new_salary, change_date)
        VALUES (OLD.emp_id, OLD.salary, NEW.salary, NOW());
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>Chaining Triggers</h4>
        <p>Triggers can fire other triggers if the triggered action causes another INSERT, UPDATE, or DELETE.</p>
    
        <h3>Best Practices for Using Triggers</h3>
        <ul>
            <li><strong>Avoid Overusing Triggers:</strong> Use triggers only when necessary to avoid complexity.</li>
            <li><strong>Keep Trigger Logic Simple:</strong> Avoid complex calculations or logic in triggers.</li>
            <li><strong>Document Your Triggers:</strong> Clearly describe the purpose and logic of each trigger.</li>
            <li><strong>Monitor Performance:</strong> Test triggers with large datasets to ensure they don't degrade performance.</li>
        </ul>
    
        <h3>Real-World Use Cases</h3>
        <ul>
            <li><strong>Audit Trails:</strong> Track every change made to critical tables.</li>
            <li><strong>Automatic Updates:</strong> Adjust related tables automatically when one table is updated.</li>
            <li><strong>Enforcing Business Rules:</strong> Prevent invalid data entries (e.g., negative values).</li>
            <li><strong>Cascading Operations:</strong> Handle cascading changes across multiple tables.</li>
            <li><strong>Alerts and Notifications:</strong> Send alerts when specific conditions are met.</li>
        </ul>
    </section>
    
    <section id="cursors">
        <h2>Cursors in SQL</h2>
        <p>
            A cursor in SQL is a database object that allows you to handle query results one row at a time. While SQL is designed to work with entire result sets, cursors enable row-by-row processing for tasks requiring granular control.
        </p>
    
        <h3>How Cursors Work</h3>
        <p>
            Think of a cursor as a pointer that navigates through rows in a dataset. Here's a typical workflow:
        </p>
        <ul>
            <li><strong>Declare:</strong> Define the cursor and specify the SQL query it will use.</li>
            <li><strong>Open:</strong> Execute the query and store the result set in the cursor.</li>
            <li><strong>Fetch:</strong> Retrieve one row at a time from the cursor.</li>
            <li><strong>Process:</strong> Perform desired operations on the fetched row.</li>
            <li><strong>Close:</strong> Close the cursor when done.</li>
            <li><strong>Deallocate:</strong> Free resources associated with the cursor.</li>
        </ul>
    
        <h3>Types of Cursors</h3>
        <ul>
            <li><strong>Implicit Cursors:</strong> Automatically created by the SQL engine for operations like SELECT, INSERT, UPDATE, or DELETE.</li>
            <li><strong>Explicit Cursors:</strong> Manually declared by users to fetch and process rows individually.</li>
        </ul>
    
        <h3>Example: Explicit Cursor</h3>
        <p>
            Suppose we have a table <code>employees</code>:
        </p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>employee_id</th>
                    <th>name</th>
                    <th>department</th>
                    <th>salary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>Alice</td>
                    <td>IT</td>
                    <td>6000</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Sales</td>
                    <td>4500</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Charlie</td>
                    <td>IT</td>
                    <td>7000</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>Diana</td>
                    <td>HR</td>
                    <td>4800</td>
                </tr>
            </tbody>
        </table>
    
        <p>Let’s print the details of employees in the "IT" department:</p>
        <div class="code-box">
            <pre><code>
    -- Step 1: Declare the Cursor
    DECLARE employee_cursor CURSOR FOR
    SELECT employee_id, name FROM employees WHERE department = 'IT';
    
    -- Step 2: Declare Variables to Hold Data
    DECLARE @employee_id INT, @name NVARCHAR(100);
    
    -- Step 3: Open the Cursor
    OPEN employee_cursor;
    
    -- Step 4: Fetch and Process Data in a Loop
    FETCH NEXT FROM employee_cursor INTO @employee_id, @name;
    
    WHILE @@FETCH_STATUS = 0
    BEGIN
        PRINT 'Employee ID: ' + CAST(@employee_id AS VARCHAR) + ', Name: ' + @name;
        FETCH NEXT FROM employee_cursor INTO @employee_id, @name;
    END
    
    -- Step 5: Close and Deallocate Cursor
    CLOSE employee_cursor;
    DEALLOCATE employee_cursor;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Output:</h3>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>Employee ID</th>
                    <th>Name</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>Alice</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Charlie</td>
                </tr>
            </tbody>
        </table>
    
        <h3>Advanced Topics: Cursor Types</h3>
        <ul>
            <li><strong>Static Cursor:</strong> Takes a snapshot of data and does not reflect changes made after the cursor is opened.</li>
            <li><strong>Dynamic Cursor:</strong> Reflects changes made to the underlying data but is resource-intensive.</li>
            <li><strong>Forward-Only Cursor:</strong> Moves only forward through the result set, offering faster performance.</li>
            <li><strong>Keyset-Driven Cursor:</strong> Uses a set of keys to fetch rows dynamically, reflecting updates but not inserts or deletes.</li>
        </ul>
    
        <h3>Performance Tips</h3>
        <ul>
            <li><strong>Avoid Unnecessary Cursors:</strong> Use set-based operations like joins or window functions whenever possible.</li>
            <li><strong>Use Forward-Only Cursors:</strong> For simple, sequential operations to minimize resource usage.</li>
            <li><strong>Minimize Locking:</strong> Fetch smaller datasets or use read-only cursors to avoid blocking other transactions.</li>
            <li><strong>Always Close and Deallocate:</strong> Release cursors promptly to free up resources.</li>
        </ul>
    
        <h3>Real-World Use Cases</h3>
        <ul>
            <li><strong>Generating Payrolls:</strong> Process employee salary records row by row to generate payslips.</li>
            <li><strong>Email Notifications:</strong> Fetch customer details and send personalized emails.</li>
            <li><strong>Data Migration:</strong> Move data from one table to another with precise control.</li>
        </ul>
    </section>
    
    <section id="udfs">
        <h2>User-Defined Functions (UDFs) in SQL</h2>
        <p>
            A User-Defined Function (UDF) is a custom function created by a user to perform specific operations in a database. Unlike built-in functions (e.g., <code>SUM</code>, <code>AVG</code>), UDFs are written to handle tasks not supported by default SQL functions or to simplify repetitive calculations.
        </p>
    
        <h3>Key Characteristics of UDFs</h3>
        <ul>
            <li><strong>Reusable:</strong> UDFs can be called multiple times in different queries.</li>
            <li><strong>Custom Logic:</strong> They allow users to implement logic tailored to specific needs.</li>
            <li><strong>Input and Output:</strong> Accept parameters as input and return a value or table as output.</li>
            <li><strong>Types:</strong> Scalar, Table-Valued, and Multi-Statement Table-Valued functions.</li>
        </ul>
    
        <h3>Benefits of Using UDFs</h3>
        <ul>
            <li>Simplify complex queries.</li>
            <li>Reduce repetitive code.</li>
            <li>Enforce consistent logic across queries.</li>
            <li>Improve maintainability by encapsulating logic in a single function.</li>
        </ul>
    
        <h3>Basics of UDFs</h3>
        <h4>1. Types of UDFs</h4>
        <ul>
            <li><strong>Scalar Functions:</strong> Return a single value.</li>
            <li><strong>Table-Valued Functions:</strong></li>
            <ul>
                <li><strong>Inline:</strong> Return a table directly using a single query.</li>
                <li><strong>Multi-Statement:</strong> Use multiple statements to build and return a table.</li>
            </ul>
        </ul>
    
        <h4>2. Basic Syntax of UDFs</h4>
        <div class="code-box">
            <pre><code>
    -- Scalar Function Syntax
    CREATE FUNCTION function_name (@parameter datatype)
    RETURNS return_datatype
    AS
    BEGIN
        RETURN (expression or value);
    END;
    
    -- Table-Valued Function Syntax
    CREATE FUNCTION function_name (@parameter datatype)
    RETURNS TABLE
    AS
    RETURN (SELECT ...);</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Beginner Examples</h3>
        <h4>1. Scalar Function: Calculate Square</h4>
        <p><strong>Step 1:</strong> Create the Function</p>
        <div class="code-box">
            <pre><code>
    CREATE FUNCTION calculate_square (@number INT)
    RETURNS INT
    AS
    BEGIN
        RETURN @number * @number;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Step 2:</strong> Use the Function</p>
        <div class="code-box">
            <pre><code>SELECT dbo.calculate_square(4) AS Square;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Output:</strong></p>
        <table class="data-table margin-lg">
            <thead>
                <tr>
                    <th>Square</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>16</td>
                </tr>
            </tbody>
        </table>
    
        <h4>2. Inline Table-Valued Function: Filter Employees by Department</h4>
        <p><strong>Step 1:</strong> Create the Function</p>
        <div class="code-box">
            <pre><code>CREATE FUNCTION get_employees_by_dept (@dept_name NVARCHAR(50))
    RETURNS TABLE
    AS
    RETURN (
        SELECT emp_id, name, department
        FROM employees
        WHERE department = @dept_name
    );</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
        <p><strong>Step 2:</strong> Use the Function</p>
        <div class="code-box">
            <pre><code>SELECT * FROM dbo.get_employees_by_dept('Sales');</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Intermediate Level: Adding Logic and Validations</h3>
        <h4>3. Scalar Function with Validation</h4>
        <p><strong>Example:</strong> Calculate Percentage (with Validation)</p>
        <div class="code-box">
            <pre><code>
    CREATE FUNCTION calculate_percentage (@score FLOAT, @total FLOAT)
    RETURNS FLOAT
    AS
    BEGIN
        IF @total = 0
            RETURN NULL; -- Avoid division by zero
        RETURN (@score / @total) * 100;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>4. Multi-Statement Table-Valued Function</h4>
        <p><strong>Example:</strong> Get High-Performing Employees</p>
        <div class="code-box">
            <pre><code>
    CREATE FUNCTION get_high_performers (@min_score INT)
    RETURNS @result TABLE (
        emp_id INT,
        name NVARCHAR(100),
        score INT
    )
    AS
    BEGIN
        INSERT INTO @result
        SELECT emp_id, name, score
        FROM employees
        WHERE score > @min_score;
    
        RETURN;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Advanced Topics: UDF Optimization and Use Cases</h3>
        <h4>5. Recursive UDFs</h4>
        <p><strong>Example:</strong> Calculate Factorial</p>
        <div class="code-box">
            <pre><code>CREATE FUNCTION factorial (@n INT)
    RETURNS INT
    AS
    BEGIN
        IF @n = 0 OR @n = 1
            RETURN 1;
        RETURN @n * dbo.factorial(@n - 1);
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h4>6. UDFs with Complex Joins</h4>
        <p><strong>Example:</strong> Employee-Manager Hierarchy</p>
        <div class="code-box">
            <pre><code>
    CREATE FUNCTION get_manager (@emp_id INT)
    RETURNS NVARCHAR(100)
    AS
    BEGIN
        DECLARE @manager_name NVARCHAR(100);
        SELECT @manager_name = m.name
        FROM employees e
        JOIN employees m ON e.manager_id = m.emp_id
        WHERE e.emp_id = @emp_id;
        RETURN @manager_name;
    END;</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    
        <h3>Best Practices for UDFs</h3>
        <ul>
            <li><strong>Use Meaningful Names:</strong> Clearly indicate the function’s purpose.</li>
            <li><strong>Document Function Logic:</strong> Include comments to explain logic and parameters.</li>
            <li><strong>Validate Inputs:</strong> Prevent unexpected errors with input validation.</li>
            <li><strong>Optimize Queries:</strong> Avoid unnecessary calculations or joins in UDFs.</li>
            <li><strong>Test Thoroughly:</strong> Ensure accuracy and performance with edge cases.</li>
        </ul>
    </section>
    
    <section id="udts">
        <h2>User-Defined Types (UDTs)</h2>
        <h3>UDTs</h3>
        <p>
            <strong>Analogy:</strong> Custom Product Packaging:
            <ul>
                <li><strong>Packaging:</strong> Combines multiple items (fields) into a single reusable unit.</li>
                <li><strong>Usage:</strong> Streamlines handling of related fields (e.g., address).</li>
            </ul>
        </p>
        <h3>Example: Creating and Using a UDT for Addresses</h3>
        <div class="code-box">
            <pre><code>
        CREATE TYPE Address AS OBJECT (
        street VARCHAR2(100),
        city VARCHAR2(50),
        state VARCHAR2(50),
        zip VARCHAR2(10)
    );
    
    CREATE TABLE customers (
        customer_id NUMBER,
        name VARCHAR2(100),
        address Address
    );
    
    -- Inserting Data
    INSERT INTO customers (customer_id, name, address)
    VALUES (1, 'John Doe', Address('123 Main St', 'Springfield', 'IL', '62701'));</code></pre>
            <button class="copy-button"><i class="fas fa-copy"></i> Copy Code</button>
        </div>
    </section>
    
    <section id="user-contributions">
        <h2>Submit Your SQL Queries or Challenges</h2>
        <p>Have an interesting SQL query or challenge? Share it with us, and we might feature it on our site with credits to you!</p>
    
        <!-- Submission Form -->
        <form id="contribution-form" class="contribution-form">
            <label for="name">Your Name:</label>
            <input type="text" id="name" name="name" placeholder="Enter your name" required>
    
            <label for="email">Your Email:</label>
            <input type="email" id="email" name="email" placeholder="Enter your email" required>
    
            <label for="query">SQL Query/Challenge:</label>
            <textarea id="query" name="query" placeholder="Enter your SQL query or challenge here" rows="5" required></textarea>
    
            <button type="submit" class="btn-submit">Submit</button>
        </form>
    
        <!-- Featured Contributions -->
        <div id="featured-contributions" class="featured-contributions">
            <h3>Featured User Submissions</h3>
            <ul>
                <li><strong>John Doe:</strong> <em>"Write a query to find the top 5 highest-paid employees."</em></li>
                <li><strong>Jane Smith:</strong> <em>"Optimize a query to retrieve customer orders within the last 30 days."</em></li>
            </ul>
        </div>
        <style>
            /* User Contributions Section */
        #user-contributions {
            background-color: #f9f9f9;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: var(--spacing-lg);
        }

        #user-contributions h2, #user-contributions h3 {
            color: var(--secondary-color);
            text-align: center;
            margin-bottom: var(--spacing-md);
        }

        .contribution-form {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            max-width: 500px;
            margin: 0 auto;
        }

        .contribution-form label {
            font-weight: bold;
            color: var(--primary-color);
        }

        .contribution-form input, .contribution-form textarea {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            font-size: 1em;
        }

        .contribution-form button {
            background-color: var(--secondary-color);
            color: #fff;
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
        }

        .contribution-form button:hover {
            background-color: var(--accent-color);
        }

        .featured-contributions ul {
            list-style: none;
            padding: 0;
            margin: var(--spacing-lg) 0;
        }

        .featured-contributions ul li {
            margin-bottom: var(--spacing-sm);
            padding-left: 10px;
            position: relative;
        }

        .featured-contributions ul li::before {
            content: "★";
            position: absolute;
            left: -15px;
            color: var(--accent-color);
        }

        </style>

        <script>
            document.getElementById("contribution-form").addEventListener("submit", function(e) {
                e.preventDefault();
            
                // Get form values
                const name = document.getElementById("name").value;
                const query = document.getElementById("query").value;
            
                // Add the contribution to the featured list
                const contributions = document.getElementById("featured-contributions").querySelector("ul");
                const newContribution = document.createElement("li");
                newContribution.innerHTML = `<strong>${name}:</strong> <em>"${query}"</em>`;
                contributions.appendChild(newContribution);
            
                // Reset form
                this.reset();
            
                // Alert the user (optional)
                alert("Thank you for your contribution!");
            });
        </script>

    </section>
</div>

    <footer class="footer">
        <p class="paragraph">Copyright 2023 TechyVia. All rights reserved.</p>
      </footer>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script>
        
      <script src="script.js"></script>
</body>
</html>