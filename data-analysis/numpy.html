<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>NumPy Tutorial - A Comprehensive Guide to Mastering Numerical Computing in Python</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">
        <link rel="stylesheet" href="style.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <!-- Header Bar -->
        <header class="header-bar">
            <span class="brand-name">TechyVia</span>
            <nav class="navbar">
                <ul class="nav-links">
                    <li><a href="#about" class="nav-link">Home</a></li>
                    <li><a href="#exercise" class="nav-link">Practice</a></li>
                    <li><a href="#project" class="nav-link">Project</a></li>
                    <li><a href="#contact" class="nav-link">Contact Us</a></li>
                </ul>
            </nav>
            <div class="toggle-menu" id="toggle-menu">☰</div>
        </header>
        
        <!-- Sidebar -->
        <div id="sideMenu" class="sideMenu" role="navigation" aria-label="Sidebar Navigation">
            <a href="#" class="closebtn" aria-label="Close sidebar">×</a>
            <nav class="sidebar-nav">
                <ul class="sidebar-links">
                    <li class="sidebar-link"><a href="#Introduction" tabindex="0">Understanding NumPy</a></li>
                    <li class="sidebar-link"><a href="#numpy-arrays" tabindex="0">Numpy Arrays</a></li>
                    <li class="sidebar-link"><a href="#array-operations" tabindex="0">Array Operations</a></li>
                    <li class="sidebar-link"><a href="#aggregation-functions" tabindex="0">Aggregation Functions</a></li>
                    <li class="sidebar-link"><a href="#element-wise-operations" tabindex="0">Element-wise Operations</a></li>
                    <li class="sidebar-link"><a href="#sorting-searching" tabindex="0">Sorting and Searching</a></li>
                    <li class="sidebar-link"><a href="#array-manipulations" tabindex="0">Advanced Array Manipulations</a></li>
                    <li class="sidebar-link"><a href="#joining-spliting" tabindex="0">Joining and Splitting Arrays</a></li>
                    <li class="sidebar-link"><a href="#broadcasting-rules" tabindex="0">Broadcasting Rules</a></li>
                    <li class="sidebar-link"><a href="#handling-missing" tabindex="0">Handling Missing Data</a></li>
                    <li class="sidebar-link"><a href="#linear-algebra" tabindex="0">Basic Linear Algebra</a></li>
                    <li class="sidebar-link"><a href="#random-number-generation" tabindex="0">Random Number Generation</a></li>
                    <li class="sidebar-link"><a href="#data-simulation" tabindex="0">Applications in Data Simulation</a></li>
                    <li class="sidebar-link"><a href="#faqs" tabindex="0">FAQS</a></li>
                </ul>
            </nav>
        </div>


        
<main id="content">
<section id="Introduction">
<h1>Introduction to NumPy</h1>

<h2>What is NumPy?</h2>
<p>NumPy, short for Numerical Python, is a powerful library for numerical computations in Python. It provides support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays. NumPy is a fundamental package for scientific computing in Python and serves as the foundation for many other scientific libraries, such as SciPy, Pandas, and Matplotlib.</p>

<h3>Importance in Scientific Computing, Data Analysis, and Machine Learning:</h3>
<ul>
<li><strong>Scientific Computing:</strong> NumPy's efficient array operations and mathematical functions make it ideal for scientific research and simulations.</li>
<li><strong>Data Analysis:</strong> NumPy arrays are used extensively in data manipulation and analysis, providing a backbone for data structures in libraries like Pandas.</li>
<li><strong>Machine Learning:</strong> Many machine learning algorithms rely on NumPy for data preprocessing, model training, and evaluation due to its speed and efficiency.</li>
</ul>

<h3>Features of NumPy</h3>
<h3>1. Multidimensional Arrays:</h3>
<p>NumPy introduces the <code>ndarray</code> object, which is a fast and space-efficient multidimensional array.</p>
<div class="code-box">
<pre><code>
import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr)</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 2x3 array.</p>

<h3>2. Broadcasting:</h3>
<p>Broadcasting allows NumPy to perform element-wise operations on arrays of different shapes.</p>
<div class="code-box">
<pre><code>
a = np.array([1, 2, 3])
b = np.array([4])
print(a + b)  # Output: [5 6 7]</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>3. Fast Operations:</h3>
<p>NumPy operations are implemented in C, making them much faster than equivalent Python code.</p>
<div class="code-box">
<pre><code>
a = np.arange(1000000)
b = np.arange(1000000)
c = a + b  # This operation is very fast</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>4. Integration with Other Libraries:</h3>
<p>NumPy integrates seamlessly with other scientific libraries like SciPy, Pandas, and Matplotlib, enhancing its functionality and ease of use.</p>

<h3>Installing NumPy</h3>
<h3>1. Using pip:</h3>
<div class="code-box">
<pre><code>pip install numpy</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>2. Using conda:</h3>
<div class="code-box">
<pre><code>conda install numpy</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>3. From Source:</h3>
<p>Download the source code from the NumPy GitHub repository. Navigate to the directory containing the source code and run:</p>
<div class="code-box">
<pre><code>python setup.py install</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>NumPy vs Python Lists</h3>
<h3>1. Performance:</h3>
<p>NumPy arrays are more efficient than Python lists due to their fixed size and homogeneous data type.</p>
<div class="code-box">
<pre><code>
import time
import numpy as np

size = 1000000
list1 = list(range(size))
list2 = list(range(size))
start = time.time()
result = [x + y for x, y in zip(list1, list2)]
print("Python list time:", time.time() - start)

array1 = np.arange(size)
array2 = np.arange(size)
start = time.time()
result = array1 + array2
print("NumPy array time:", time.time() - start)</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>2. Memory Usage:</h3>
<p>NumPy arrays consume less memory compared to Python lists due to their compact storage.</p>
<div class="code-box">
<pre><code>
import sys
import numpy as np

list1 = list(range(1000))
array1 = np.arange(1000)
print("Python list size:", sys.getsizeof(list1))
print("NumPy array size:", array1.nbytes)</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>3. Functionality:</h3>
<p>NumPy provides a wide range of mathematical functions and operations that are not available with Python lists.</p>
<div class="code-box">
<pre><code>
import numpy as np

array = np.array([1, 2, 3])
print(np.mean(array))  # Output: 2.0
print(np.std(array))   # Output: 0.816496580927726</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="numpy-arrays">
<h2>NumPy Arrays</h2>
<h3>Creating Arrays</h3>
<p>NumPy provides several functions to create arrays, each serving different purposes. Here, we'll discuss how to create arrays using <code>array()</code>, <code>zeros()</code>, <code>ones()</code>, <code>empty()</code>, and <code>arange()</code>, along with practical examples.</p>

<h3>Using <code>array()</code></h3>
<p>The <code>array()</code> function is used to create an array from a list or a tuple.</p>

<h4>Example 1: Creating a 1D array from a list</h4>
<div class="code-box">
    <pre><code>
import numpy as np

list_data = [1, 2, 3, 4, 5]
array_1d = np.array(list_data)
print(array_1d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This code converts a Python list into a NumPy 1D array.</p>

<h4>Example 2: Creating a 2D array from a list of lists</h4>
<div class="code-box">
    <pre><code>
import numpy as np

list_of_lists = [[1, 2, 3], [4, 5, 6]]
array_2d = np.array(list_of_lists)
print(array_2d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This code converts a list of lists into a NumPy 2D array.</p>

<h3>Using <code>zeros()</code></h3>
<p>The <code>zeros()</code> function creates an array filled with zeros. You can specify the shape of the array.</p>

<h4>Example 1: Creating a 1D array of zeros</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_zeros_1d = np.zeros(5)
print(array_zeros_1d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 1D array with five zeros.</p>

<h4>Example 2: Creating a 2D array of zeros</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_zeros_2d = np.zeros((3, 4))
print(array_zeros_2d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 3x4 array filled with zeros.</p>

<h3>Using <code>ones()</code></h3>
<p>The <code>ones()</code> function creates an array filled with ones. You can specify the shape of the array.</p>

<h4>Example 1: Creating a 1D array of ones</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_ones_1d = np.ones(5)
print(array_ones_1d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 1D array with five ones.</p>

<h4>Example 2: Creating a 2D array of ones</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_ones_2d = np.ones((2, 3))
print(array_ones_2d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 2x3 array filled with ones.</p>

<h3>Using <code>empty()</code></h3>
<p>The <code>empty()</code> function creates an array without initializing its entries. The values in the array are whatever happens to be in memory at that location.</p>

<h4>Example 1: Creating a 1D empty array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_empty_1d = np.empty(5)
print(array_empty_1d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 1D array with uninitialized values.</p>

<h4>Example 2: Creating a 2D empty array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_empty_2d = np.empty((2, 3))
print(array_empty_2d)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 2x3 array with uninitialized values.</p>

<h3>Using <code>arange()</code></h3>
<p>The <code>arange()</code> function creates an array with evenly spaced values within a given interval.</p>

<h4>Example 1: Creating a range of values from 0 to 9</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_range = np.arange(10)
print(array_range)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 1D array with values from 0 to 9.</p>

<h4>Example 2: Creating a range of values with a step size</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_range_step = np.arange(0, 10, 2)
print(array_range_step)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates a 1D array with values from 0 to 8, with a step size of 2.</p>

<h3>Array Data Types</h3>
<h3>Importance of Data Types</h3>
<p>In NumPy, data types (dtypes) are crucial because they define the type of elements stored in an array. This affects the array's memory usage and the operations that can be performed on it. NumPy supports a variety of data types, including integers, floats, complex numbers, and more. Understanding and specifying data types can lead to more efficient and error-free code.</p>

<h3>Key Points:</h3>
<ul>
    <li><strong>Memory Efficiency:</strong> Choosing the appropriate data type can save memory. For example, using <code>int8</code> instead of <code>int64</code> for small integers.</li>
    <li><strong>Performance:</strong> Operations on arrays with specific data types can be faster.</li>
    <li><strong>Precision:</strong> Selecting the right data type ensures the precision needed for calculations.</li>
</ul>

<h3>Specifying Data Types</h3>
<p>You can specify the data type of a NumPy array when you create it using the <code>dtype</code> parameter.</p>

<h3>Example 1: Creating an array with integer data type</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_int = np.array([1, 2, 3, 4], dtype=np.int32)
print(array_int)
print(array_int.dtype)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates an array of integers with the <code>int32</code> data type.</p>

<h3>Example 2: Creating an array with float data type</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_float = np.array([1.1, 2.2, 3.3, 4.4], dtype=np.float64)
print(array_float)
print(array_float.dtype)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This creates an array of floats with the <code>float64</code> data type.</p>

<h3>Converting Data Types</h3>
<p>You can convert the data type of an existing array using the <code>astype()</code> method.</p>

<h3>Example 1: Converting an integer array to float</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_int = np.array([1, 2, 3, 4], dtype=np.int32)
array_float = array_int.astype(np.float64)
print(array_float)
print(array_float.dtype)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This converts an integer array to a float array.</p>

<h3>Example 2: Converting a float array to integer</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_float = np.array([1.1, 2.2, 3.3, 4.4], dtype=np.float64)
array_int = array_float.astype(np.int32)
print(array_int)
print(array_int.dtype)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This converts a float array to an integer array, truncating the decimal part.</p>

<h3>Common Data Types in NumPy</h3>
<ul>
    <li><strong>Integer Types:</strong> <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></li>
    <li><strong>Unsigned Integer Types:</strong> <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li>
    <li><strong>Float Types:</strong> <code>float16</code>, <code>float32</code>, <code>float64</code></li>
    <li><strong>Complex Types:</strong> <code>complex64</code>, <code>complex128</code></li>
</ul>

<h3>Benefits and Use Cases</h3>
<ul>
    <li><strong>Memory Optimization:</strong> Using smaller data types like <code>int8</code> or <code>float16</code> can significantly reduce memory usage in large datasets.</li>
    <li><strong>Performance Improvement:</strong> Operations on arrays with specific data types can be optimized for speed.</li>
    <li><strong>Precision Control:</strong> Ensuring the right level of precision for scientific calculations by choosing appropriate float or complex types.</li>
</ul>

<h3>Common Pitfalls and Troubleshooting Tips</h3>
<h3>Overflow Errors:</h3>
<p>Using a data type that is too small can lead to overflow errors. For example, using <code>int8</code> for large integers.</p>
<div class="code-box">
    <pre><code>
import numpy as np

array_small_int = np.array([127], dtype=np.int8)
array_small_int += 1
print(array_small_int)  # Output: -128 (overflow)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Loss of Precision:</h3>
<p>Converting from a higher precision type to a lower precision type can result in loss of data.</p>
<div class="code-box">
    <pre><code>
import numpy as np

array_high_precision = np.array([1.123456789], dtype=np.float64)
array_low_precision = array_high_precision.astype(np.float32)
print(array_low_precision)  # Output: [1.1234568]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Array Shape and Dimension</h3>
<h3>Shape</h3>
<p>The shape of a NumPy array is a tuple that indicates the size of the array along each dimension. It is accessed using the <code>shape</code> attribute.</p>

<h3>Example 1: Checking the shape of a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([1, 2, 3, 4, 5])
print(array_1d.shape)  # Output: (5,)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This shows that the array has 5 elements in one dimension.</p>

<h3>Example 2: Checking the shape of a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
print(array_2d.shape)  # Output: (2, 3)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This indicates that the array has 2 rows and 3 columns.</p>

<h3>ndim</h3>
<p>The <code>ndim</code> attribute returns the number of dimensions (axes) of the array.</p>

<h3>Example 1: Checking the number of dimensions of a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([1, 2, 3, 4, 5])
print(array_1d.ndim)  # Output: 1</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This confirms that the array is one-dimensional.</p>

<h3>Example 2: Checking the number of dimensions of a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(array_3d.ndim)  # Output: 3</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This shows that the array has three dimensions.</p>

<h3>Resizing Arrays</h3>
<p>Resizing arrays can be done using the <code>reshape()</code> method, which returns a new array with the specified shape, or the <code>resize()</code> method, which modifies the array in place.</p>

<h3>Example 1: Using <code>reshape()</code> to change the shape of an array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5, 6])
reshaped_array = array.reshape((2, 3))
print(reshaped_array)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This reshapes the 1D array into a 2x3 array.</p>

<h3>Example 2: Using <code>resize()</code> to change the shape of an array in place</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5, 6])
array.resize((3, 2))
print(array)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This resizes the array to a 3x2 array, modifying the original array.</p>

<h3>Deep Dive into Different Models</h3>
<h3>Flattening an Array:</h3>
<p>Flattening converts a multi-dimensional array into a 1D array.</p>

<h4>Example 1: Using <code>flatten()</code> method</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
flattened_array = array_2d.flatten()
print(flattened_array)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Using <code>ravel()</code> method</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
raveled_array = array_2d.ravel()
print(raveled_array)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Expanding Dimensions:</h3>
<p>Expanding dimensions can be done using <code>np.newaxis</code> or <code>expand_dims()</code>.</p>

<h4>Example 1: Using <code>np.newaxis</code></h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([1, 2, 3])
expanded_array = array_1d[:, np.newaxis]
print(expanded_array)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This adds a new axis, converting the 1D array into a 2D column vector.</p>

<h4>Example 2: Using <code>expand_dims()</code></h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([1, 2, 3])
expanded_array = np.expand_dims(array_1d, axis=0)
print(expanded_array)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This adds a new axis, converting the 1D array into a 2D row vector.</p>


<h3>Indexing in NumPy</h3>
<h3>Basic Indexing</h3>
<p>Indexing in NumPy allows you to access individual elements of an array using their indices. NumPy arrays are zero-indexed, meaning the first element has an index of 0.</p>

<h3>Example 1: Indexing a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([10, 20, 30, 40, 50])
print(array_1d[0])  # Output: 10
print(array_1d[3])  # Output: 40</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This accesses the first and fourth elements of the array.</p>

<h3>Example 2: Indexing a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(array_2d[0, 1])  # Output: 2
print(array_2d[2, 2])  # Output: 9</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This accesses the element in the first row, second column, and the element in the third row, third column.</p>

<h3>Slicing in NumPy</h3>
<p>Slicing allows you to access a range of elements in an array. The syntax for slicing is <code>start:stop:step</code>.</p>

<h3>Example 1: Slicing a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([10, 20, 30, 40, 50])
print(array_1d[1:4])  # Output: [20 30 40]
print(array_1d[:3])   # Output: [10 20 30]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This slices the array to get elements from index 1 to 3 and from the start to index 2.</p>

<h3>Example 2: Slicing a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(array_2d[1:, 1:])  # Output: [[5 6] [8 9]]
print(array_2d[:2, :2])  # Output: [[1 2] [4 5]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This slices the array to get a sub-array from the second row and second column onwards, and another sub-array from the first two rows and columns.</p>

<h3>Boolean Indexing in NumPy</h3>
<p>Boolean indexing allows you to select elements from an array using boolean conditions.</p>

<h3>Example 1: Boolean indexing with a condition</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([10, 20, 30, 40, 50])
bool_idx = array_1d > 25
print(array_1d[bool_idx])  # Output: [30 40 50]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This selects elements greater than 25.</p>

<h3>Example 2: Boolean indexing with multiple conditions</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
bool_idx = (array_2d > 2) & (array_2d < 8)
print(array_2d[bool_idx])  # Output: [3 4 5 6 7]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This selects elements greater than 2 and less than 8.</p>

<h3>Advanced Indexing</h3>
<h3>Integer Array Indexing</h3>
<p>You can use arrays of integers to index another array. This allows you to construct new arrays by picking elements from the original array.</p>

<h4>Example</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_1d = np.array([10, 20, 30, 40, 50])
indices = np.array([0, 2, 4])
print(array_1d[indices])  # Output: [10 30 50]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Fancy Indexing</h3>
<p>Fancy indexing is similar to integer array indexing but allows for more complex selections.</p>

<h4>Example</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
rows = np.array([0, 1, 2])
cols = np.array([2, 1, 0])
print(array_2d[rows, cols])  # Output: [3 5 7]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Combining Indexing and Slicing</h3>
<p>You can combine different types of indexing and slicing to access more complex parts of arrays.</p>

<h3>Example</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(array_2d[1:, [0, 2]])  # Output: [[4 6] [7 9]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="array-operations">
<h2>Array Operations in NumPy</h2>
<p>NumPy provides a wide range of mathematical operations that can be performed on arrays. These operations are element-wise, meaning they are applied to each element of the array individually. Let's explore addition, subtraction, multiplication, division, and broadcasting with practical examples.</p>

<h3>Addition</h3>
<p>You can add two arrays element-wise using the <code>+</code> operator or the <code>np.add()</code> function.</p>

<h3>Example 1: Adding two 1D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
result = array1 + array2
print(result)  # Output: [5 7 9]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Adding two 2D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.add(array1, array2)
print(result)  # Output: [[ 6  8] [10 12]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Subtraction</h3>
<p>You can subtract one array from another element-wise using the <code>-</code> operator or the <code>np.subtract()</code> function.</p>

<h3>Example 1: Subtracting two 1D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([10, 20, 30])
array2 = np.array([1, 2, 3])
result = array1 - array2
print(result)  # Output: [ 9 18 27]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Subtracting two 2D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[10, 20], [30, 40]])
array2 = np.array([[1, 2], [3, 4]])
result = np.subtract(array1, array2)
print(result)  # Output: [[ 9 18] [27 36]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Multiplication</h3>
<p>Element-wise multiplication can be performed using the <code>*</code> operator or the <code>np.multiply()</code> function.</p>

<h3>Example 1: Multiplying two 1D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
result = array1 * array2
print(result)  # Output: [ 4 10 18]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Multiplying two 2D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.multiply(array1, array2)
print(result)  # Output: [[ 5 12] [21 32]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Division</h3>
<p>Element-wise division can be performed using the <code>/</code> operator or the <code>np.divide()</code> function.</p>

<h3>Example 1: Dividing two 1D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([10, 20, 30])
array2 = np.array([2, 4, 5])
result = array1 / array2
print(result)  # Output: [5. 5. 6.]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Dividing two 2D arrays</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[10, 20], [30, 40]])
array2 = np.array([[2, 4], [5, 8]])
result = np.divide(array1, array2)
print(result)  # Output: [[5. 5.] [6. 5.]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Broadcasting</h3>
<p>Broadcasting allows NumPy to perform element-wise operations on arrays of different shapes. This is particularly useful when you need to perform operations between arrays of different dimensions.</p>

<h3>Example 1: Broadcasting a scalar to a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3])
scalar = 2
result = array * scalar
print(result)  # Output: [2 4 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Broadcasting a 1D array to a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = np.array([1, 2, 3])
result = array_2d + array_1d
print(result)  # Output: [[ 2  4  6] [ 5  7  9]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="aggregation-functions">
<h2>Aggregation Functions</h2>
<p>NumPy provides a variety of aggregation functions that allow you to perform operations like summing, averaging, finding the minimum and maximum values, and more. These functions can be applied to entire arrays or along specific axes.</p>

<h3>Sum</h3>
<p>The <code>sum()</code> function adds up all the elements in an array. You can also specify an axis to sum along.</p>

<h3>Example 1: Summing all elements in a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5])
total_sum = np.sum(array)
print(total_sum)  # Output: 15</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Summing elements along an axis in a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
sum_along_axis0 = np.sum(array, axis=0)
sum_along_axis1 = np.sum(array, axis=1)
print(sum_along_axis0)  # Output: [5 7 9]
print(sum_along_axis1)  # Output: [ 6 15]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 3: Summing elements along both axes in a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
sum_along_axis0 = np.sum(array, axis=0)
sum_along_axis1 = np.sum(array, axis=1)
sum_along_axis2 = np.sum(array, axis=2)
print(sum_along_axis0)  # Output: [[ 6  8] [10 12]]
print(sum_along_axis1)  # Output: [[ 4  6] [12 14]]
print(sum_along_axis2)  # Output: [[ 3  7] [11 15]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Mean</h3>
<p>The <code>mean()</code> function calculates the average of the elements in an array. You can also specify an axis to calculate the mean along.</p>

<h3>Example 1: Calculating the mean of all elements in a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5])
average = np.mean(array)
print(average)  # Output: 3.0</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Calculating the mean along an axis in a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
mean_along_axis0 = np.mean(array, axis=0)
mean_along_axis1 = np.mean(array, axis=1)
print(mean_along_axis0)  # Output: [2.5 3.5 4.5]
print(mean_along_axis1)  # Output: [2. 5.]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 3: Calculating the mean along both axes in a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
mean_along_axis0 = np.mean(array, axis=0)
mean_along_axis1 = np.mean(array, axis=1)
mean_along_axis2 = np.mean(array, axis=2)
print(mean_along_axis0)  # Output: [[3. 4.] [5. 6.]]
print(mean_along_axis1)  # Output: [[2. 3.] [6. 7.]]
print(mean_along_axis2)  # Output: [[1.5 3.5] [5.5 7.5]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Min</h3>
<p>The <code>min()</code> function finds the minimum value in an array. You can also specify an axis to find the minimum along.</p>

<h3>Example 1: Finding the minimum value in a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5])
minimum_value = np.min(array)
print(minimum_value)  # Output: 1</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Finding the minimum value along an axis in a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
min_along_axis0 = np.min(array, axis=0)
min_along_axis1 = np.min(array, axis=1)
print(min_along_axis0)  # Output: [1 2 3]
print(min_along_axis1)  # Output: [1 4]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 3: Finding the minimum value along both axes in a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
min_along_axis0 = np.min(array, axis=0)
min_along_axis1 = np.min(array, axis=1)
min_along_axis2 = np.min(array, axis=2)
print(min_along_axis0)  # Output: [[1 2] [3 4]]
print(min_along_axis1)  # Output: [[1 2] [5 6]]
print(min_along_axis2)  # Output: [[1 3] [5 7]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Max</h3>
<p>The <code>max()</code> function finds the maximum value in an array. You can also specify an axis to find the maximum along.</p>

<h3>Example 1: Finding the maximum value in a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5])
maximum_value = np.max(array)
print(maximum_value)  # Output: 5</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Finding the maximum value along an axis in a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
max_along_axis0 = np.max(array, axis=0)
max_along_axis1 = np.max(array, axis=1)
print(max_along_axis0)  # Output: [4 5 6]
print(max_along_axis1)  # Output: [3 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 3: Finding the maximum value along both axes in a 3D array<h3>Example 3: Finding the maximum value along both axes in a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
max_along_axis0 = np.max(array, axis=0)
max_along_axis1 = np.max(array, axis=1)
max_along_axis2 = np.max(array, axis=2)
print(max_along_axis0)  # Output: [[5 6] [7 8]]
print(max_along_axis1)  # Output: [[3 4] [7 8]]
print(max_along_axis2)  # Output: [[2 4] [6 8]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Axis-Based Operations</h3>
<p>Aggregation functions can be applied along specific axes of an array. The <code>axis</code> parameter specifies the axis along which the operation is performed.</p>

<h3>Example 1: Summing along different axes</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
sum_axis0 = np.sum(array, axis=0)  # Sum along columns
sum_axis1 = np.sum(array, axis=1)  # Sum along rows
print(sum_axis0)  # Output: [5 7 9]
print(sum_axis1)  # Output: [ 6 15]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 2: Calculating the mean along different axes</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
mean_axis0 = np.mean(array, axis=0)  # Mean along columns
mean_axis1 = np.mean(array, axis=1)  # Mean along rows
print(mean_axis0)  # Output: [2.5 3.5 4.5]
print(mean_axis1)  # Output: [2. 5.]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Example 3: Finding the minimum and maximum along different axes</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
min_axis0 = np.min(array, axis=0)  # Min along columns
max_axis0 = np.max(array, axis=0)  # Max along columns
min_axis1 = np.min(array, axis=1)  # Min along rows
max_axis1 = np.max(array, axis=1)  # Max along rows
print(min_axis0)  # Output: [1 2 3]
print(max_axis0)  # Output: [4 5 6]
print(min_axis1)  # Output: [1 4]
print(max_axis1)  # Output: [3 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="element-wise-operations">
<h2>Element-wise Operations</h2>

<h3>Universal Functions (ufuncs)</h3>
<p>Universal functions, or ufuncs, are a core feature of NumPy that allow you to perform element-wise operations on arrays. These functions operate on each element of the array independently, making them highly efficient for numerical computations. Some common ufuncs include <code>np.sin</code>, <code>np.log</code>, <code>np.exp</code>, and many others.</p>

<h3>1. <code>np.sin</code></h3>
<p>The <code>np.sin</code> function computes the trigonometric sine of each element in the array. The input array should contain angles in radians.</p>

<h4>Example 1: Applying <code>np.sin</code> to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

angles = np.array([0, np.pi/2, np.pi])
sine_values = np.sin(angles)
print(sine_values)  # Output: [0. 1. 0.]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This calculates the sine of 0, π/2, and π.</p>

<h4>Example 2: Applying <code>np.sin</code> to a 2D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

angles = np.array([[0, np.pi/4], [np.pi/2, np.pi]])
sine_values = np.sin(angles)
print(sine_values)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This calculates the sine of each element in the 2D array.</p>

<h3>2. <code>np.log</code></h3>
<p>The <code>np.log</code> function computes the natural logarithm (base e) of each element in the array. The input array should contain positive numbers.</p>

<h4>Example 1: Applying <code>np.log</code> to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

values = np.array([1, np.e, np.e**2])
log_values = np.log(values)
print(log_values)  # Output: [0. 1. 2.]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This calculates the natural logarithm of 1, e, and e².</p>

<h4>Example 2: Applying <code>np.log</code> to a 2D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

values = np.array([[1, 10], [100, 1000]])
log_values = np.log(values)
print(log_values)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This calculates the natural logarithm of each element in the 2D array.</p>

<h3>Benefits and Use Cases</h3>
<ul>
    <li><strong>Efficiency:</strong> Ufuncs are implemented in C, making them much faster than equivalent Python loops.</li>
    <li><strong>Broadcasting:</strong> Ufuncs support broadcasting, allowing operations on arrays of different shapes.</li>
    <li><strong>Vectorization:</strong> Ufuncs enable vectorized operations, which are more efficient and concise than looping over array elements.</li>
</ul>

<h3>Common Pitfalls and Troubleshooting Tips</h3>
<h3>Domain Errors</h3>
<p>Ensure that the input values are within the domain of the function. For example, <code>np.log</code> requires positive numbers.</p>
<div class="code-box">
    <pre><code>
import numpy as np

values = np.array([-1, 0, 1])
try:
    log_values = np.log(values)
except ValueError as e:
    print(e)  # Output: ValueError: invalid value encountered in log</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Precision Issues</h3>
<p>Be aware of precision issues when dealing with very large or very small numbers.</p>
<div class="code-box">
    <pre><code>
import numpy as np

large_values = np.array([1e10, 1e20, 1e30])
log_values = np.log(large_values)
print(log_values)  # Output: [23.02585093 46.05170186 69.07755279]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="sorting-searching">
<h2>Sorting and Searching</h2>

<h3>Sorting</h3>
<p>NumPy provides the <code>sort()</code> function to sort the elements of an array. This function can sort arrays in ascending order by default, and it can also sort along a specified axis.</p>

<h3>Example 1: Sorting a 1D array</h3>
<div class="code-box">
    <pre><code>import numpy as np

array = np.array([3, 1, 2, 5, 4])
sorted_array = np.sort(array)
print(sorted_array)  # Output: [1 2 3 4 5]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This sorts the elements of the array in ascending order.</p>

<h3>Example 2: Sorting a 2D array along an axis</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[3, 1, 2], [5, 4, 6]])
sorted_array_axis0 = np.sort(array, axis=0)
sorted_array_axis1 = np.sort(array, axis=1)
print(sorted_array_axis0)
# Output:
# [[3 1 2]
#  [5 4 6]]
print(sorted_array_axis1)
# Output:
# [[1 2 3]
#  [4 5 6]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This sorts the array along the specified axis (0 for columns, 1 for rows).</p>

<h3>Example 3: Sorting a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[3, 1, 2], [6, 5, 4]], [[9, 7, 8], [12, 11, 10]]])
sorted_array = np.sort(array, axis=2)
print(sorted_array)
# Output:
# [[[ 1  2  3]
#   [ 4  5  6]]
#  [[ 7  8  9]
#   [10 11 12]]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This sorts the 3D array along the third axis.</p>

<h3>argsort()</h3>
<p>The <code>argsort()</code> function returns the indices that would sort an array. This is useful for indirect sorting, where you need the sorted order of indices rather than the sorted values themselves.</p>

<h3>Example 1: Using <code>argsort()</code> on a 1D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([3, 1, 2, 5, 4])
sorted_indices = np.argsort(array)
print(sorted_indices)  # Output: [1 2 0 4 3]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This returns the indices that would sort the array.</p>

<h3>Example 2: Using <code>argsort()</code> on a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[3, 1, 2], [5, 4, 6]])
sorted_indices_axis0 = np.argsort(array, axis=0)
sorted_indices_axis1 = np.argsort(array, axis=1)
print(sorted_indices_axis0)
# Output:
# [[0 0 0]
#  [1 1 1]]
print(sorted_indices_axis1)
# Output:
# [[1 2 0]
#  [1 0 2]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This returns the indices that would sort the array along the specified axis.</p>

<h3>Example 3: Using <code>argsort()</code> on a 3D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[[3, 1, 2], [6, 5, 4]], [[9, 7, 8], [12, 11, 10]]])
sorted_indices = np.argsort(array, axis=2)
print(sorted_indices)
# Output:
# [[[1 2 0]
#   [2 1 0]]
#  [[1 2 0]
#   [2 1 0]]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This returns the indices that would sort the 3D array along the third axis.</p>

<h3>where()</h3>
<p>The <code>where()</code> function returns the indices of elements in an array that satisfy a given condition. It can also be used to select elements from two arrays based on a condition.</p>

<h3>Example 1: Using <code>where()</code> to find indices of elements that satisfy a condition</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5])
indices = np.where(array > 3)
print(indices)  # Output: (array([3, 4]),)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This returns the indices of elements greater than 3.</p>

<h3>Example 2: Using <code>where()</code> to select elements from two arrays based on a condition</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3, 4, 5])
array2 = np.array([10, 20, 30, 40, 50])
result = np.where(array1 > 3, array1, array2)
print(result)  # Output: [10 20 30  4  5]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This selects elements from <code>array1</code> where the condition is true, and from <code>array2</code> where the condition is false.</p>

<h3>Example 3: Using <code>where()</code> with a 2D array</h3>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
indices = np.where(array > 3)
print(indices)  # Output: (array([1, 1, 1]), array([0, 1, 2]))</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p>This returns the indices of elements greater than 3 in the 2D array.</p>
</section>

<section id="array-manipulations">
<h2>Advanced Array Manipulations</h2>

<h3>Reshaping and Flattening</h3>
<p>NumPy provides several functions to manipulate the shape and structure of arrays, including <code>reshape()</code>, <code>ravel()</code>, and <code>flatten()</code>. These functions are essential for transforming arrays to fit the needs of various operations and algorithms.</p>

<h3>reshape()</h3>
<p>The <code>reshape()</code> function allows you to change the shape of an array without changing its data. The new shape must be compatible with the original shape, meaning the total number of elements must remain the same.</p>

<h4>Example 1: Reshaping a 1D array to a 2D array</h4>
<div class="code-box">
    <pre><code>import numpy as np

array_1d = np.array([1, 2, 3, 4, 5, 6])
array_2d = array_1d.reshape((2, 3))
print(array_2d)
# Output:
# [[1 2 3]
#  [4 5 6]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Reshaping a 2D array to a 3D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_3d = array_2d.reshape((2, 1, 3))
print(array_3d)
# Output:
# [[[1 2 3]]
#  [[4 5 6]]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 3: Reshaping a 3D array to a 2D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
array_2d = array_3d.reshape((4, 3))
print(array_2d)
# Output:
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]
#  [10 11 12]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>ravel()</h3>
<p>The <code>ravel()</code> function returns a contiguous flattened array. Unlike <code>flatten()</code>, <code>ravel()</code> returns a view of the original array whenever possible. This means that modifying the result of <code>ravel()</code> may modify the original array.</p>

<h4>Example 1: Flattening a 2D array to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = array_2d.ravel()
print(array_1d)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Modifying the flattened array affects the original array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = array_2d.ravel()
array_1d[0] = 99
print(array_2d)
# Output:
# [[99  2  3]
#  [ 4  5  6]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 3: Flattening a 3D array to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
array_1d = array_3d.ravel()
print(array_1d)  # Output: [ 1  2  3  4  5  6  7  8  9 10 11 12]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>flatten()</h3>
<p>The <code>flatten()</code> function returns a copy of the array collapsed into one dimension. Unlike <code>ravel()</code>, <code>flatten()</code> always returns a copy, so modifications to the result do not affect the original array.</p>

<h4>Example 1: Flattening a 2D array to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = array_2d.flatten()
print(array_1d)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Modifying the flattened array does not affect the original array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = array_2d.flatten()
array_1d[0] = 99
print(array_2d)
# Output:
# [[1 2 3]
#  [4 5 6]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 3: Flattening a 3D array to a 1D array</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
array_1d = array_3d.flatten()
print(array_1d)  # Output: [ 1  2  3  4  5  6  7  8  9 10 11 12]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Benefits and Use Cases</h3>
<ul>
    <li><strong>reshape():</strong> Useful for preparing data for machine learning models, where inputs often need to be in a specific shape.</li>
    <li><strong>ravel():</strong> Efficient for temporary flattening of arrays for operations that require a 1D view without copying data.</li>
    <li><strong>flatten():</strong> Ideal when a permanent, independent flattened copy of the array is needed.</li>
</ul>
</section>

<section id="joining-spliting">
<h2>Joining and Splitting Arrays</h2>

<h3>Joining Arrays</h3>
<p>NumPy provides several functions to join arrays, allowing you to combine multiple arrays into one. The most commonly used functions for joining arrays are <code>concatenate()</code>, <code>vstack()</code>, and <code>hstack()</code>.</p>

<h3>1. <code>concatenate()</code></h3>
<p>The <code>concatenate()</code> function joins a sequence of arrays along an existing axis.</p>

<h4>Example 1: Concatenating 1D arrays</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
result = np.concatenate((array1, array2))
print(result)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Concatenating 2D arrays along axis 0 (rows)</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.concatenate((array1, array2), axis=0)
print(result)
# Output:
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 3: Concatenating 2D arrays along axis 1 (columns)</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.concatenate((array1, array2), axis=1)
print(result)
# Output:
# [[1 2 5 6]
#  [3 4 7 8]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>2. <code>vstack()</code></h3>
<p>The <code>vstack()</code> function stacks arrays vertically (row-wise).</p>

<h4>Example 1: Stacking 1D arrays vertically</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
result = np.vstack((array1, array2))
print(result)
# Output:
# [[1 2 3]
#  [4 5 6]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Stacking 2D arrays vertically</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.vstack((array1, array2))
print(result)
# Output:
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>3. <code>hstack()</code></h3>
<p>The <code>hstack()</code> function stacks arrays horizontally (column-wise).</p>

<h4>Example 1: Stacking 1D arrays horizontally</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
result = np.hstack((array1, array2))
print(result)  # Output: [1 2 3 4 5 6]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Stacking 2D arrays horizontally</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
result = np.hstack((array1, array2))
print(result)
# Output:
# [[1 2 5 6]
#  [3 4 7 8]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Splitting Arrays</h3>
<p>NumPy also provides functions to split arrays into multiple sub-arrays. The most commonly used function for splitting arrays is <code>split()</code>.</p>

<h3>1. <code>split()</code></h3>
<p>The <code>split()</code> function splits an array into multiple sub-arrays along a specified axis.</p>

<h4>Example 1: Splitting a 1D array into equal parts</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3, 4, 5, 6])
result = np.split(array, 3)
print(result)
# Output: [array([1, 2]), array([3, 4]), array([5, 6])]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 2: Splitting a 2D array along axis 1 (columns)</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6]])
result = np.split(array, 3, axis=1)
print(result)
# Output:
# [array([[1],
#         [4]]),
#  array([[2],
#         [5]]),
#  array([[3],
#         [6]])]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h4>Example 3: Splitting a 2D array along axis 0 (rows)</h4>
<div class="code-box">
    <pre><code>
import numpy as np

array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
result = np.split(array, 3, axis=0)
print(result)
# Output:
# [array([[1, 2, 3]]),
#  array([[4, 5, 6]]),
#  array([[7, 8, 9]])]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="broadcasting-rules">
  <h2>Broadcasting Rules</h2>
  <p>Broadcasting is a powerful feature in NumPy that allows you to perform element-wise operations on arrays of different shapes. When operating on two arrays, NumPy compares their shapes element-wise, starting with the trailing dimensions. It applies the following rules to determine if the shapes are compatible:</p>
  <ol>
    <li><strong>If the arrays have different numbers of dimensions, the shape of the smaller-dimensional array is padded with ones on its left side.</strong></li>
    <li><strong>If the shape of the arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.</strong></li>
    <li><strong>If the shapes are not compatible after applying the above rules, a <code>ValueError</code> is raised.</strong></li>
  </ol>
  <p>Let's explore these rules with practical examples.</p>
  
  <h3>Example 1: Broadcasting with a Scalar</h3>
  <p>When you perform operations between an array and a scalar, the scalar is broadcasted to the shape of the array.</p>
  
  <h3>Example: Adding a scalar to a 1D array</h3>
  <div class="code-box">
    <pre><code>
import numpy as np

array = np.array([1, 2, 3])
scalar = 5
result = array + scalar
print(result)  # Output: [6 7 8]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
  </div>
  
  <h3>Example 2: Broadcasting with Different Dimensions</h3>
  <p>When the arrays have different numbers of dimensions, the smaller-dimensional array is padded with ones on its left side.</p>
  
  <h3>Example: Adding a 1D array to a 2D array</h3>
  <div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = np.array([10, 20, 30])
result = array_2d + array_1d
print(result)
# Output:
# [[11 22 33]
#  [14 25 36]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
  </div>
  
  <h3>Example 3: Broadcasting with Mismatched Shapes</h3>
  <p>When the shapes do not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.</p>
  
  <h3>Example: Multiplying a 2D array with a 1D array</h3>
  <div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = np.array([1, 2, 3])
result = array_2d * array_1d
print(result)
# Output:
# [[ 1  4  9]
#  [ 4 10 18]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
  </div>
  
  <h3>Example 4: Incompatible Shapes</h3>
  <p>If the shapes are not compatible after applying the broadcasting rules, a <code>ValueError</code> is raised.</p>
  
  <h3>Example: Attempting to add arrays with incompatible shapes</h3>
  <div class="code-box">
    <pre><code>
import numpy as np

array_2d = np.array([[1, 2, 3], [4, 5, 6]])
array_1d = np.array([1, 2])
try:
    result = array_2d + array_1d
except ValueError as e:
    print(e)  # Output: operands could not be broadcast together with shapes (2,3) (4,)</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
  </div>
  
  <h3>Benefits and Use Cases</h3>
  <ul>
    <li><strong>Memory Efficiency:</strong> Broadcasting avoids the need to create large intermediate arrays, saving memory.</li>
    <li><strong>Code Simplicity:</strong> It allows for more concise and readable code by eliminating the need for explicit loops.</li>
    <li><strong>Performance:</strong> Broadcasting operations are implemented in C, making them faster than equivalent Python loops.</li>
  </ul>
</section>

<section id="handling-missing">
    <h2>Handling Missing Data</h2>
    <p>In data analysis, it's common to encounter missing or undefined data. NumPy provides several tools to handle such cases, including <code>np.nan</code>, <code>np.isnan()</code>, and <code>np.nanmean()</code>. These tools help you manage and analyze datasets with missing values effectively.</p>
    
    <h3>np.nan</h3>
    <p><code>np.nan</code> is a special floating-point value that represents "Not a Number." It is used to denote missing or undefined data in NumPy arrays.</p>
    
    <h3>Example 1: Creating an array with missing values</h3>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array_with_nan = np.array([1, 2, np.nan, 4, 5])
  print(array_with_nan)
  # Output: [ 1.  2. nan  4.  5.]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>Example 2: Using <code>np.nan</code> in a 2D array</h3>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array_with_nan = np.array([[1, 2, 3], [4, np.nan, 6]])
  print(array_with_nan)
  # Output:
  # [[ 1.  2.  3.]
  #  [ 4. nan  6.]]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>np.isnan()</h3>
    <p>The <code>np.isnan()</code> function returns a boolean array indicating whether each element is <code>np.nan</code>.</p>
    
    <h3>Example 1: Identifying missing values in a 1D array</h3>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array = np.array([1, 2, np.nan, 4, 5])
  nan_mask = np.isnan(array)
  print(nan_mask)
  # Output: [False False  True False False]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>Example 2: Identifying missing values in a 2D array</h3>
    <div class="code-box">
      <pre><code>
import numpy as np
  
array = np.array([[1, 2, 3], [4, np.nan, 6]])
nan_mask = np.isnan(array)
print(nan_mask)
# Output:
# [[False False False]
#  [False  True False]]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>np.nanmean()</h3>
    <p>The <code>np.nanmean()</code> function computes the mean of an array, ignoring <code>np.nan</code> values. This is useful for calculating the average of datasets with missing values.</p>
    
    <h3>Example 1: Calculating the mean of a 1D array with missing values</h3>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array = np.array([1, 2, np.nan, 4, 5])
  mean_value = np.nanmean(array)
  print(mean_value)  # Output: 3.0</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>Example 2: Calculating the mean along an axis in a 2D array with missing values</h3>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array = np.array([[1, 2, 3], [4, np.nan, 6]])
  mean_value_axis0 = np.nanmean(array, axis=0)
  mean_value_axis1 = np.nanmean(array, axis=1)
  print(mean_value_axis0)  # Output: [2.5 2.  4.5]
  print(mean_value_axis1)  # Output: [2.  5.]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>Use Cases</h3>
    <ul>
      <li><strong>Data Cleaning:</strong> Use <code>np.nan</code> to mark missing or undefined data points in your dataset.</li>
      <li><strong>Data Analysis:</strong> Use <code>np.isnan()</code> to identify and handle missing values during data analysis.</li>
      <li><strong>Statistical Calculations:</strong> Use <code>np.nanmean()</code> to compute the mean of datasets with missing values, ensuring that the missing data does not skew the results.</li>
    </ul>
    
    <h3>Common Pitfalls and Troubleshooting Tips</h3>
    <h3>Propagation of <code>np.nan</code></h3>
    <p>Arithmetic operations involving <code>np.nan</code> will result in <code>np.nan</code>. Be cautious when performing calculations.</p>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array = np.array([1, 2, np.nan, 4, 5])
  result = array + 1
  print(result)  # Output: [ 2.  3. nan  5.  6.]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    
    <h3>Handling <code>np.nan</code> in Integer Arrays</h3>
    <p>NumPy does not support <code>np.nan</code> in integer arrays. Convert the array to a float type if you need to use <code>np.nan</code>.</p>
    <div class="code-box">
      <pre><code>
  import numpy as np
  
  array = np.array([1, 2, 3, 4, 5], dtype=float)
  array[2] = np.nan
  print(array)  # Output: [ 1.  2. nan  4.  5.]</code></pre>
      <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
</section>

<section id="linear-algebra">
    <h2 class="seo-friendly-heading">Linear Algebra with NumPy</h2>

    <h3>Basic Linear Algebra</h3>

    <h3>1. Dot Product</h3>
    <p>The dot product of two arrays is a sum of the element-wise products. In NumPy, you can compute the dot product using the <code>np.dot()</code> function.</p>

    <h4>Example 1: Dot product of two 1D arrays</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
dot_product = np.dot(array1, array2)
print(dot_product)  # Output: 32</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The dot product is calculated as \(1*4 + 2*5 + 3*6 = 32\).</p>
<br>
<h4>Example 2: Dot product of two 2D arrays (matrix multiplication)</h4>
<div class="code-box">
    <pre><code>
import numpy as np

matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
dot_product = np.dot(matrix1, matrix2)
print(dot_product)
# Output:
# [[19 22]
#  [43 50]]</code></pre>
    <button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
<p><strong>Explanation:</strong> The dot product (matrix multiplication) is calculated as:</p>
<div class="math">
    \[
    \begin{bmatrix}
    1 & 2 \\
    3 & 4
    \end{bmatrix}
    \times
    \begin{bmatrix}
    5 & 6 \\
    7 & 8
    \end{bmatrix}
    =
    \begin{bmatrix}
    (1 \cdot 5 + 2 \cdot 7) & (1 \cdot 6 + 2 \cdot 8) \\
    (3 \cdot 5 + 4 \cdot 7) & (3 \cdot 6 + 4 \cdot 8)
    \end{bmatrix}
    =
    \begin{bmatrix}
    19 & 22 \\
    43 & 50
    \end{bmatrix}
    \]
</div>

    <h3>2. Matrix Multiplication</h3>
    <p>Matrix multiplication can be performed using the <code>@</code> operator or the <code>np.matmul()</code> function.</p>

    <h4>Example 1: Matrix multiplication using the <code>@</code> operator</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
result = matrix1 @ matrix2
print(result)
# Output:
# [[19 22]
#  [43 50]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The <code>@</code> operator performs matrix multiplication, yielding the same result as <code>np.dot()</code>.</p>
<br>
    <h4>Example 2: Matrix multiplication using <code>np.matmul()</code></h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
result = np.matmul(matrix1, matrix2)
print(result)
# Output:
# [[19 22]
#  [43 50]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> <code>np.matmul()</code> performs matrix multiplication, yielding the same result as <code>np.dot()</code> and the <code>@</code> operator.</p>

    <h3>3. Transpose</h3>
    <p>The transpose of a matrix is obtained by swapping its rows with its columns. In NumPy, you can transpose a matrix using the <code>T</code> attribute.</p>

    <h4>Example 1: Transposing a 2D array</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix = np.array([[1, 2, 3], [4, 5, 6]])
transpose_matrix = matrix.T
print(transpose_matrix)
# Output:
# [[1 4]
#  [2 5]
#  [3 6]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The transpose of the matrix swaps rows and columns.</p><br>

    <h4>Example 2: Transposing a 3D array</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
transpose_array = array_3d.transpose((1, 0, 2))
print(transpose_array)
# Output:
# [[[1 2]
#   [5 6]]
#  [[3 4]
#   [7 8]]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The <code>transpose()</code> method with specified axes rearranges the dimensions of the array.</p>

    <h3>Solving Linear Equations</h3>
    <p>The <code>np.linalg.solve()</code> function is used to solve a system of linear equations of the form \(Ax = b\), where \(A\) is a coefficient matrix and \(b\) is a constant vector.</p>

    <h4>Example: Solving a system of linear equations</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
x = np.linalg.solve(A, b)
print(x)  # Output: [2. 3.]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The solution to the system of equations is found by solving:
    <br>
    \[
    \begin{cases}
    3x_1 + x_2 = 9 \\
    x_1 + 2x_2 = 8
    \end{cases}
    \]
    The solution is \(x_1 = 2\) and \(x_2 = 3\).</p>

    <h3>Eigenvalues and Eigenvectors</h3>
    <p>The <code>np.linalg.eig()</code> function computes the eigenvalues and right eigenvectors of a square array.</p>

    <h4>Example: Calculating eigenvalues and eigenvectors</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix = np.array([[4, -2], [1, 1]])
eigenvalues, eigenvectors = np.linalg.eig(matrix)
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:", eigenvectors)
# Output:
# Eigenvalues: [3. 2.]
# Eigenvectors:
# [[ 0.89442719  0.70710678]
#  [ 0.4472136  -0.70710678]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The eigenvalues and eigenvectors of the matrix are calculated. The eigenvalues are 3 and 2, and the corresponding eigenvectors are \([0.89442719, 0.4472136]\) and \([0.70710678, -0.70710678]\).</p>

    <h3>Matrix Operations</h3>

    <h3>1. <code>det()</code></h3>
    <p>The <code>np.linalg.det()</code> function computes the determinant of an array.</p>

    <h4>Example: Calculating the determinant of a matrix</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix = np.array([[1, 2], [3, 4]])
determinant = np.linalg.det(matrix)
print(determinant)  # Output: -2.0000000000000004</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The determinant of the matrix is calculated as \(1*4 - 2*3 = -2\).</p>

    <h3>2. <code>inv()</code></h3>
    <p>The <code>np.linalg.inv()</code> function computes the inverse of a matrix.</p>

    <h4>Example: Calculating the inverse of a matrix</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix = np.array([[1, 2], [3, 4]])
inverse_matrix = np.linalg.inv(matrix)
print(inverse_matrix)
# Output:
# [[-2.   1. ]
#  [ 1.5 -0.5]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The inverse of the matrix is calculated. The product of the matrix and its inverse yields the identity matrix.</p>

    <h3>3. <code>norm()</code></h3>
    <p>The <code>np.linalg.norm()</code> function computes the norm of an array.</p>

    <h4>Example: Calculating the Frobenius norm of a matrix</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

matrix = np.array([[1, 2], [3, 4]])
norm_value = np.linalg.norm(matrix)
print(norm_value)  # Output: 5.477225575051661</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Explanation:</strong> The Frobenius norm is calculated as the square root of the sum of the absolute squares of its elements:
    <br>
    \[
    \sqrt{1^2 + 2^2 + 3^2 + 4^2} = \sqrt{1 + 4 + 9 + 16} = \sqrt{30} \approx 5.477
    \]</p>
</section>

<section id="random-number-generation">
    <h2 class="seo-friendly-heading">Random Number Generation</h2>

    <h3>Random Sampling</h3>
    <p>NumPy provides a powerful suite of functions for generating random numbers and sampling from various distributions through the <code>np.random</code> module. These functions are essential for simulations, statistical modeling, and data analysis.</p>

    <h3>1. Generating Random Numbers</h3>
    <p>You can generate random numbers using the <code>np.random.rand()</code> function, which creates an array of the given shape with random samples from a uniform distribution over [0, 1).</p>

    <h4>Example 1: Generating a single random number</h4>
    <div class="code-box">
        <pre><code>import numpy as np

random_number = np.random.rand()
print(random_number)  # Output: A random number between 0 and 1</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h4>Example 2: Generating a 1D array of random numbers</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

random_array = np.random.rand(5)
print(random_array)  # Output: An array of 5 random numbers between 0 and 1</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>2. Uniform Distribution</h3>
    <p>The <code>np.random.uniform()</code> function generates random numbers from a uniform distribution over a specified interval [low, high).</p>

    <h4>Example 1: Generating a single random number from a uniform distribution</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

random_number = np.random.uniform(1, 10)
print(random_number)  # Output: A random number between 1 and 10</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h4>Example 2: Generating a 2D array of random numbers from a uniform distribution</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

random_array = np.random.uniform(1, 10, size=(3, 3))
print(random_array)
# Output: A 3x3 array of random numbers between 1 and 10</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>3. Normal Distribution</h3>
    <p>The <code>np.random.normal()</code> function generates random numbers from a normal (Gaussian) distribution with a specified mean and standard deviation.</p>

    <h4>Example 1: Generating a single random number from a normal distribution</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

random_number = np.random.normal(0, 1)
print(random_number)  # Output: A random number from a normal distribution with mean 0 and std 1</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h4>Example 2: Generating a 1D array of random numbers from a normal distribution</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

random_array = np.random.normal(0, 1, size=5)
print(random_array)  # Output: An array of 5 random numbers from a normal distribution with mean 0 and std 1</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Benefits and Use Cases</h3>

    <ul>
      <li><strong>Simulations and Modeling</strong>
        <ul>
          <li>Monte Carlo Simulations: Analyze complex systems, predict outcomes, and estimate uncertainties.</li>
          <li>Stochastic Processes: Model random phenomena in finance (e.g., stock prices), biology (e.g., population dynamics), and more.</li>
        </ul>
      </li>
    
      <li><strong>Statistical Analysis and Modeling</strong>
        <ul>
          <li>Synthetic Data Generation: Create datasets for testing statistical models, validating assumptions, and training machine learning algorithms.</li>
          <li>Hypothesis Testing and Validation: Use random sampling to assess the validity of statistical hypotheses and models.</li>
        </ul>
      </li>
    
      <li><strong>Machine Learning and Data Science</strong>
        <ul>
          <li>Data Augmentation: Enhance dataset diversity and size through random transformations to improve model robustness and generalizability.</li>
          <li>Cross-Validation Techniques: Use random sampling to split data into training and testing sets for model evaluation and hyperparameter tuning.</li>
          <li>Random Forests and Ensemble Methods: Leverage random sampling to construct diverse decision trees and improve predictive accuracy.</li>
        </ul>
      </li>
    
      <li><strong>Gaming, Education, and Research</strong>
        <ul>
          <li>Game Development: Create engaging, unpredictable experiences through procedural generation and random events.</li>
          <li>Educational Tools: Develop interactive, randomized learning materials for more effective student engagement.</li>
          <li>Research and Development: Utilize random number generation in simulations and models across various scientific disciplines.</li>
        </ul>
      </li>
    </ul>

    <h3>Common Pitfalls and Troubleshooting Tips</h3>
    <h3>Reproducibility</h3>
    <p>For reproducible results, set a random seed using <code>np.random.seed()</code>.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
random_number = np.random.rand()
print(random_number)  # Output: The same random number every time you run this code</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Distribution Parameters</h3>
    <p>Ensure that the parameters for the distribution functions are correctly specified to avoid unexpected results.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

random_array = np.random.uniform(10, 1, size=5)  # Incorrect: low > high
print(random_array)  # Output: An array of random numbers between 1 and 10, not 10 and 1</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
</section>

<section id="reproducibility">
    <h2 class="seo-friendly-heading">Reproducibility</h2>

    <h3>Setting Seeds with <code>np.random.seed()</code></h3>
    <p>In computational experiments and data analysis, reproducibility is crucial. It ensures that your results can be consistently replicated, which is essential for debugging, sharing your work, and validating findings. One way to achieve reproducibility in random number generation is by setting a random seed using <code>np.random.seed()</code>.</p>

    <p>When you set a seed, you initialize the random number generator to a fixed state. This means that every time you run your code with the same seed, you will get the same sequence of random numbers. This is particularly useful in scenarios where you need consistent results, such as in simulations, machine learning experiments, and randomized algorithms.</p>

    <h3>Example 1: Setting a seed for reproducibility</h3>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
random_numbers = np.random.rand(5)
print(random_numbers)
# Output: [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>By setting the seed to 42, the sequence of random numbers generated by <code>np.random.rand(5)</code> will always be the same every time you run this code.</p>

    <h3>Example 2: Consistent results across different runs</h3>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
random_numbers_1 = np.random.rand(5)
print(random_numbers_1)
# Output: [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]

np.random.seed(42)
random_numbers_2 = np.random.rand(5)
print(random_numbers_2)
# Output: [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>Here, setting the seed to 42 before generating random numbers ensures that <code>random_numbers_1</code> and <code>random_numbers_2</code> are identical.</p>

    <h3>Benefits and Use Cases</h3>
    <ul>
        <li><strong>Debugging:</strong> Setting a seed allows you to reproduce the exact sequence of random numbers, making it easier to debug and trace issues in your code.</li>
        <li><strong>Experimentation:</strong> In machine learning and data science, reproducibility is essential for comparing different models and experiments under the same conditions.</li>
        <li><strong>Collaboration:</strong> Sharing code with a fixed seed ensures that collaborators can replicate your results exactly, facilitating better collaboration and validation.</li>
    </ul>

    <h3>Common Pitfalls and Troubleshooting Tips</h3>
    <h3>Changing Seeds</h3>
    <p>If you change the seed or do not set a seed, the sequence of random numbers will differ each time you run the code.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
random_numbers_1 = np.random.rand(5)
print(random_numbers_1)
# Output: [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]

np.random.seed(24)
random_numbers_2 = np.random.rand(5)
print(random_numbers_2)
# Output: [0.9600173  0.69951207 0.99986799 0.30147295 0.45905478]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Global State</h3>
    <p>Setting a seed affects the global state of the random number generator. If other parts of your code rely on random numbers, they will also be influenced by the seed.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
random_numbers_1 = np.random.rand(5)
print(random_numbers_1)
# Output: [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]

random_numbers_2 = np.random.rand(5)
print(random_numbers_2)
# Output: [0.15599452 0.05808361 0.86617615 0.60111501 0.70807258]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
</section>

<section id="data-simulation">
    <h2 class="seo-friendly-heading">Applications in Data Simulation</h2>

    <h3>Simulation</h3>
    <p>Simulation involves generating synthetic data that mimics real-world processes. This is useful in various fields such as finance, engineering, and scientific research. NumPy's random number generation capabilities make it an excellent tool for simulations.</p>

    <h3>Example 1: Simulating a Random Walk</h3>
    <p>A random walk is a path that consists of a series of random steps. It is often used to model stock prices or physical processes.</p>
    <div class="code-box">
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(42)
steps = 1000
random_steps = np.random.choice([-1, 1], size=steps)
random_walk = np.cumsum(random_steps)

plt.plot(random_walk)
plt.title("Random Walk Simulation")
plt.xlabel("Step")
plt.ylabel("Position")
plt.show()</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>This code simulates a random walk of 1000 steps and plots the resulting path.</p>

    <h3>Example 2: Simulating Dice Rolls</h3>
    <p>Simulating dice rolls can be useful in games and probability studies.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
rolls = np.random.randint(1, 7, size=1000)
print("First 10 rolls:", rolls[:10])</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>This code simulates rolling a six-sided die 1000 times and prints the first 10 results.</p>

    <h3>Bootstrapping</h3>
    <p>Bootstrapping is a statistical method that involves resampling with replacement to estimate the distribution of a statistic. It is commonly used to estimate confidence intervals and assess the variability of a sample.</p>

    <h3>Example 1: Bootstrapping the Mean</h3>
    <p>Bootstrapping can be used to estimate the confidence interval of the mean of a sample.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
data = np.random.normal(0, 1, size=100)
bootstrap_means = []

for _ in range(1000):
    bootstrap_sample = np.random.choice(data, size=len(data), replace=True)
    bootstrap_means.append(np.mean(bootstrap_sample))

confidence_interval = np.percentile(bootstrap_means, [2.5, 97.5])
print("95% Confidence Interval for the Mean:", confidence_interval)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>This code generates 1000 bootstrap samples from the original data and calculates the 95% confidence interval for the mean.</p>

    <h3>Example 2: Bootstrapping the Median</h3>
    <p>Similarly, bootstrapping can be used to estimate the confidence interval of the median.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

np.random.seed(42)
data = np.random.normal(0, 1, size=100)
bootstrap_medians = []

for _ in range(1000):
    bootstrap_sample = np.random.choice(data, size=len(data), replace=True)
    bootstrap_medians.append(np.median(bootstrap_sample))

confidence_interval = np.percentile(bootstrap_medians, [2.5, 97.5])
print("95% Confidence Interval for the Median:", confidence_interval)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p>This code generates 1000 bootstrap samples from the original data and calculates the 95% confidence interval for the median.</p>
</section>

<section id="performance-optimization">
    <h2 class="seo-friendly-heading">Performance Optimization with NumPy</h2>

    <h3>Vectorization: The Power of Avoiding Loops</h3>
    <p><strong>What is Vectorization?</strong><br>
    Vectorization is a computing paradigm where operations are applied to entire arrays at once, rather than looping over individual elements. This approach is particularly effective in NumPy, significantly boosting performance by leveraging optimized C code under the hood.</p>

    <p><strong>Importance of Avoiding Loops</strong></p>
    <ul>
        <li><strong>Speed:</strong> Vectorized operations are much faster than using Python loops. This is because NumPy's vectorized operations are implemented in C, which executes more quickly than Python.</li>
        <li><strong>Readability and Maintainability:</strong> Vectorized code is often more concise and easier to understand, making your projects more maintainable.</li>
        <li><strong>Scalability:</strong> As your datasets grow, the efficiency of vectorized operations ensures your code scales better.</li>
    </ul>

    <h3>Example: Loop vs. Vectorized Operation</h3>

    <h4>Looping (Slower)</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

# Generate two large arrays
arr1 = np.random.rand(1000000)
arr2 = np.random.rand(1000000)

# Using a loop (slow)
result = np.zeros_like(arr1)
for i in range(len(arr1)):
    result[i] = arr1[i] + arr2[i]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h4>Vectorized Operation (Faster)</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

# Generate two large arrays
arr1 = np.random.rand(1000000)
arr2 = np.random.rand(1000000)

# Vectorized operation (fast)
result = arr1 + arr2</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Memory Layout: Understanding Contiguous Arrays and the Order Parameter</h3>

    <p><strong>Contiguous Arrays</strong></p>
    <ul>
        <li><strong>Definition:</strong> A contiguous array is one where the elements are stored in adjacent memory locations. This layout enhances the performance of array operations.</li>
        <li><strong>Benefit:</strong> Operations on contiguous arrays are faster because the CPU can more efficiently fetch data from memory.</li>
    </ul>

    <p><strong>Order Parameter (C vs. F)</strong></p>
    <ul>
        <li><strong>C (C-Style, Default):</strong> Last index varies the fastest. Suitable for most use cases, especially when working with image and signal processing libraries.</li>
    </ul>
    <div class="code-box">
        <pre><code>
import numpy as np

# C-Style (Default)
arr_c = np.arange(6).reshape(2, 3)
print(arr_c)
# Output:
# [[0 1 2]
#  [3 4 5]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <ul>
        <li><strong>F (Fortran-Style):</strong> First index varies the fastest. Often used in linear algebra and when interfacing with Fortran code.</li>
    </ul>
    <div class="code-box">
        <pre><code>
import numpy as np

# Fortran-Style
arr_f = np.arange(6, dtype=int).reshape(2, 3, order='F')
print(arr_f)
# Output:
# [[0 3]
#  [1 4]
#  [2 5]]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Efficient Storage: Saving and Loading with <code>np.save</code> and <code>np.load</code></h3>

    <p><strong>Why Efficient Storage Matters</strong></p>
    <ul>
        <li><strong>Data Safety:</strong> Securely store valuable data for future use.</li>
        <li><strong>Transfer Efficiency:</strong> Share or transfer data between projects or collaborators more effectively.</li>
        <li><strong>Reproducibility:</strong> Ensure experiments or analyses can be replicated by saving the exact state of your data.</li>
    </ul>

    <p><strong>Saving with <code>np.save</code></strong></p>
    <p><strong>Basic Usage:</strong> Save a NumPy array to a <code>.npy</code> file.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

# Generate an array
data = np.random.rand(3, 3)

# Save to a file named 'data.npy'
np.save('data', data)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <p><strong>Saving Multiple Arrays:</strong> Use <code>np.savez</code> for multiple arrays, stored in a single <code>.npz</code> file.</p>
    <div class="code-box">
        <pre><code>
import numpy as np

# Generate arrays
data1 = np.random.rand(3, 3)
data2 = np.random.rand(2, 2)

# Save multiple arrays to a file named 'dataset.npz'
np.savez('dataset', data1=data1, data2=data2)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <p><strong>Loading with <code>np.load</code></strong></p>
    <p><strong>Loading a Single Array (<code>*.npy</code>):</strong></p>
    <div class="code-box">
        <pre><code>
import numpy as np

# Load from 'data.npy'
loaded_data = np.load('data.npy')
print(loaded_data)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <p><strong>Loading Multiple Arrays (<code>*.npz</code>):</strong></p>
    <div class="code-box">
        <pre><code>
import numpy as np

# Load from 'dataset.npz'
loaded_dataset = np.load('dataset.npz')

# Access the loaded arrays by their names
print(loaded_dataset['data1'])
print(loaded_dataset['data2'])</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <p><strong>Tips for Efficient Storage with <code>np.save</code> and <code>np.load</code></strong></p>
    <ul>
        <li><strong>Use <code>.npy</code> for Single Arrays:</strong> For simplicity and compatibility, especially when sharing a single array.</li>
        <li><strong>Leverage <code>.npz</code> for Multiple Arrays:</strong> To keep related data together and simplify data management.</li>
        <li><strong>Verify Integrity:</strong> After loading, quickly inspect your data to ensure it matches expectations.</li>
        <li><strong>Document Your Data:</strong> Store a README or metadata file alongside your <code>.npy</code>/<code>.npz</code> files describing the data's origin, structure, and any specific loading instructions.</li>
    </ul>

    <h3>Best Practices for Performance Optimization with NumPy</h3>
    <ul>
        <li><strong>Profile Your Code:</strong> Identify bottlenecks before optimizing.</li>
        <li><strong>Vectorize Operations:</strong> Prefer NumPy's built-in functions over loops.</li>
        <li><strong>Ensure Contiguous Memory Allocation:</strong> For arrays that require sequential access.</li>
        <li><strong>Leverage Just-In-Time (JIT) Compilation:</strong> Tools like Numba can further accelerate performance-critical sections.</li>
        <li><strong>Stay Updated with NumPy:</strong> New versions often include performance enhancements and new features.</li>
    </ul>

    <h3>Example Use Case: Scientific Computing with Vectorized Operations</h3>
    <p>Suppose we're analyzing the growth of multiple microbial cultures over time, modeled by an exponential growth equation: \(A(t) = A_0 e^{kt}\).</p>
    <div class="code-box">
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# Initial amounts and growth rates for 5 cultures
A0_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
k_values = np.array([0.1, 0.2, 0.3, 0.4, 0.5])

# Time points (vectorized)
t = np.linspace(0, 10, 100)

# Vectorized computation for all cultures at all time points
A = A0_values[:, np.newaxis] * np.exp(k_values[:, np.newaxis] * t)

# Plotting
for i, label in enumerate(['Culture {}'.format(j) for j in range(1, 6)]):
plt.plot(t, A[i], label=label)
plt.legend()
plt.xlabel('Time')
plt.ylabel('Amount')
plt.title('Growth of Microbial Cultures')
plt.show()</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<p>This example demonstrates how vectorized operations in NumPy can efficiently compute and visualize the growth of multiple microbial cultures, showcasing the power of performance optimization in scientific computing.</p>
</section>

<section id="visualization-debugging">
<h2 class="seo-friendly-heading">Visualization and Debugging</h2>

<h3>Debugging Arrays</h3>
<p>Effective debugging is crucial for identifying and resolving issues in your NumPy arrays. Here are some key tools and techniques for debugging arrays:</p>

<h3><code>np.set_printoptions()</code></h3>
<p><strong>Purpose:</strong> Customize the display of NumPy arrays to aid in debugging.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Suppressing Precision:</strong> Limit the decimal places for floating-point numbers.</li>
<li><strong>Truncating Large Arrays:</strong> Display only the edges of large arrays, saving screen space.</li>
<li><strong>Displaying Array Shapes:</strong> Highlight the shape of arrays for quick dimensional verification.</li>
</ul>

<h4>Example: Using <code>np.set_printoptions()</code></h4>
<div class="code-box">
<pre><code>
import numpy as np

# Original array display
large_array = np.random.rand(20, 20)
print("Original Display:")
print(large_array)

# Custom display options
np.set_printoptions(precision=2, threshold=5, edgeitems=2)
print("\nCustom Display:")
print(large_array)

# Reset to default display options
np.set_printoptions(precision=8, threshold=1000, edgeitems=3)</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>

<h3>Shape Debugging</h3>
<p><strong>Purpose:</strong> Verify the dimensions of your arrays to catch shape-related errors early.</p>
<p><strong>Techniques:</strong></p>
<ul>
<li><strong>Explicit Checks:</strong> Use <code>assert</code> statements with <code>array.shape</code> to validate expected dimensions.</li>
<li><strong>Print or Log Shapes:</strong> Temporarily add <code>print(array.shape)</code> to monitor shape changes during execution.</li>
</ul>

<h4>Example: Shape Debugging</h4>
<div class="code-box">
<pre><code>
import numpy as np

# Create an array
my_array = np.random.rand(3, 4)

# Explicit shape check
assert my_array.shape == (3, 4), "Array shape mismatch. Expected (3, 4), got {}".format(my_array.shape)

# Temporarily print shape for debugging
print("Debug - Array Shape:", my_array.shape)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Visualization with NumPy</h3>
    <p>Visualization is a powerful tool for understanding and communicating insights from your data. Here’s how to integrate NumPy arrays with Matplotlib for informative plotting:</p>

    <h3>Matplotlib Integration</h3>
    <p><strong>Purpose:</strong> Leverage Matplotlib’s plotting capabilities with your NumPy arrays.</p>
    <p><strong>Key Plots for NumPy Arrays:</strong></p>
    <ul>
        <li><strong>Line Plots:</strong> Ideal for trending over time or across categories.</li>
        <li><strong>Scatter Plots:</strong> Useful for relationship analysis between two variables.</li>
        <li><strong>Histograms:</strong> Perfect for understanding the distribution of a single variable.</li>
        <li><strong>Heatmaps:</strong> Great for visualizing the relationship between two categorical variables.</li>
    </ul>

    <h4>Example: Plotting with Matplotlib</h4>
    <div class="code-box">
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# Generate sample data
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Create a figure and axis object
fig, ax = plt.subplots()

# Line plot
ax.plot(x, y1, label='Sine')
ax.plot(x, y2, label='Cosine')

# Customize the plot
ax.set(title='Sine and Cosine Plot', xlabel='X', ylabel='Value')
ax.legend()
ax.grid(True)

# Display the plot
plt.show()</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Output: </strong></p>
<img src="images/cos-img.png" alt="sin cosine Output" style="max-width:100%; height:auto;">

    <h3>Additional Tips for Effective Visualization</h3>
    <ul>
        <li><strong>Keep It Simple:</strong> Avoid clutter; focus on the key message.</li>
        <li><strong>Choose Colors Wisely:</strong> Ensure accessibility and differentiate series effectively.</li>
        <li><strong>Interactivity:</strong> Consider tools like Plotly for interactive visualizations when appropriate.</li>
        <li><strong>Contextualize:</strong> Provide enough context (e.g., labels, titles) for your audience to understand the plot without additional explanation.</li>
    </ul>

    <h3>Use Case: Visualizing Scientific Data with NumPy and Matplotlib</h3>
    <div class="code-box">
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# Experimental data
time_hours = np.array([0, 1, 2, 3, 4, 5])
temp_reaction1 = np.array([20, 25, 30, 35, 40, 45])
temp_reaction2 = np.array([22, 24, 28, 32, 38, 42])

# Create the plot
plt.figure(figsize=(10, 6))
plt.plot(time_hours, temp_reaction1, marker='o', linestyle='-', color='blue', label='Reaction 1')
plt.plot(time_hours, temp_reaction2, marker='s', linestyle='--', color='red', label='Reaction 2')

# Customize the plot
plt.title('Temperature Trends for Chemical Reactions')
plt.xlabel('Time (Hours)')
plt.ylabel('Temperature (°C)')
plt.legend(loc='upper left')
plt.grid(True)
plt.xticks(time_hours)  # Set x-axis ticks to match data points
plt.ylim(15, 50)  # Set y-axis limits for better visualization

# Display the plot
plt.show()</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>
    <p><strong>Output: </strong></p>
    <img src="images/temp-trends.png" alt="sin cosine Output" style="max-width:100%; height:auto;">

    <h3>Debugging and Visualization Checklist</h3>
    <h3>Debugging:</h3>
    <ul>
        <li>Verify array shapes and dimensions using <code>array.shape</code>.</li>
        <li>Utilize <code>np.set_printoptions()</code> for customized array display.</li>
        <li>Employ explicit checks with <code>assert</code> statements for critical conditions.</li>
    </ul>

    <h3>Visualization:</h3>
    <ul>
        <li>Choose the most informative plot type for your data (e.g., line, scatter, histogram).</li>
        <li>Ensure plot readability through clear labels, titles, and legends.</li>
        <li>Consider interactivity for complex or multi-variable data using tools like Plotly.</li>
    </ul>

    <h3>Additional Resources</h3>
    <ul>
        <li><a href="https://numpy.org/doc/" target="_blank">NumPy Documentation</a></li>
        <li><a href="https://matplotlib.org/stable/tutorials/index.html" target="_blank">Matplotlib Documentation</a></li>
        <li><a href="https://plotly.com/python/" target="_blank">Plotly Interactive Visualization</a></li>
    </ul>
</section>

<section id="numpy-cloud-data-engineering">
    <h2 class="seo-friendly-heading">NumPy in Cloud and Data Engineering</h2>

    <h3>NumPy for Big Data</h3>
    <p>While NumPy is highly efficient for numerical computing, it has inherent limitations when dealing with extremely large datasets that don't fit into memory. Here’s how to address these limitations and integrate with Dask for scalability:</p>

    <h3>Limitations of NumPy for Big Data:</h3>
    <ul>
        <li><strong>Memory Constraints:</strong> NumPy arrays reside in memory, limiting their size.</li>
        <li><strong>Computational Scalability:</strong> Not designed for distributed computing out-of-the-box.</li>
    </ul>

    <h3>Integration with Dask for Large Datasets:</h3>
    <p><strong>What is Dask?</strong> A parallel computing library for analytic computing, seamlessly scaling up from NumPy and Pandas.</p>
    <p><strong>Dask Arrays:</strong> Similar API to NumPy, but for larger-than-memory computations, leveraging multiple CPUs or even clusters.</p>

    <h4>Example: Transitioning from NumPy to Dask Arrays</h4>
    <div class="code-box">
        <pre><code>
# NumPy (in-memory)
import numpy as np
large_array = np.random.random((10000, 10000))

# Dask Array (scalable, larger-than-memory)
import dask.array as da
large_dask_array = da.random.random((100000, 100000), chunks=(1000, 1000))</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Integration with Pandas</h3>
    <p>Pandas, a library for data manipulation and analysis, heavily relies on NumPy. Understanding this integration is crucial for efficient data science workflows:</p>

    <h3>How Pandas Builds Upon NumPy:</h3>
    <ul>
        <li><strong>Series (1-D labeled array):</strong> Built on top of NumPy’s ndarray, adding labels and index functionality.</li>
        <li><strong>DataFrames (2-D labeled data structure):</strong> Extends the concept of Series to multiple dimensions, leveraging NumPy for core computations.</li>
    </ul>

    <h3>Benefits of the NumPy-Pandas Ecosystem:</h3>
    <ul>
        <li><strong>Unified Data Types:</strong> Seamless integration and type consistency across libraries.</li>
        <li><strong>Performance:</strong> Efficient computations through NumPy’s optimized C code.</li>
    </ul>

    <h4>Example: NumPy to Pandas DataFrame</h4>
    <div class="code-box">
        <pre><code>
import numpy as np
import pandas as pd

# NumPy array
np_data = np.array([[1, 2], [3, 4]])

# Convert to Pandas DataFrame
df = pd.DataFrame(np_data, columns=['A', 'B'])
print(df)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>NumPy and Cloud Computing</h3>
    <p>NumPy can be effectively utilized in cloud computing pipelines for scalable numerical computations. Here are some tips for integrating NumPy with cloud platforms and optimizing performance:</p>

    <h3>Use of NumPy in Cloud Pipelines:</h3>
    <ul>
        <li><strong>Serverless Computing (e.g., AWS Lambda, Google Cloud Functions):</strong> Ideal for small to medium-sized numerical tasks.</li>
        <li><strong>Containerized Environments (e.g., Docker on Kubernetes):</strong> Suitable for larger, more complex computations, ensuring dependency consistency.</li>
    </ul>

    <h3>Performance Tips for Cloud Deployments:</h3>
    <ul>
        <li><strong>Optimize Dependency Sizes:</strong> Minimize library dependencies to reduce cloud storage costs and speed up deployments.</li>
        <li><strong>Leverage Cloud Accelerators (e.g., GPU, TPU):</strong> For massively parallel computations, significantly reducing processing times.</li>
        <li><strong>Monitor and Auto-Scaling:</strong> Dynamically adjust computational resources based on workload demand.</li>
    </ul>

    <h4>Example: Deploying a NumPy Application on Google Cloud Run</h4>
    <div class="code-box">
        <pre><code>
# Step 1: Create a Python environment with NumPy
python -m venv numpy-env
source numpy-env/bin/activate
pip install numpy

# Step 2: Develop your NumPy application
# app.py
import numpy as np

def compute(request):
    data = np.random.rand(100, 100)
    result = np.sum(data)
    return str(result)

# Step 3: Containerize with Docker
# Dockerfile
FROM python:slim

# Set working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]

# Step 4: Deploy on Google Cloud Run
gcloud run deploy --image=gcr.io/your-project-id/your-image-name --platform=managed --region=your-region --allow-unauthenticated</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>Additional Resources</h3>
    <ul>
        <li><a href="https://dask.org/" target="_blank">Dask Documentation</a></li>
        <li><a href="https://pandas.pydata.org/docs/" target="_blank">Pandas Documentation</a></li>
        <li><a href="https://cloud.google.com/run/docs" target="_blank">Google Cloud Run Documentation</a></li>
        <li><a href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" target="_blank">AWS Lambda Documentation (for Serverless NumPy Deployments)</a></li>
    </ul>

    <h3>Best Practices for NumPy in Cloud and Data Engineering</h3>
    <h3>Scalability:</h3>
    <ul>
        <li>Identify potential bottlenecks in your NumPy code.</li>
        <li>Leverage Dask for larger-than-memory computations.</li>
    </ul>

    <h3>Performance:</h3>
    <ul>
        <li>Optimize dependency sizes for cloud deployments.</li>
        <li>Utilize cloud accelerators (GPU, TPU) for parallel computations.</li>
    </ul>

    <h3>Integration:</h3>
    <ul>
        <li>Seamlessly integrate NumPy with Pandas for data manipulation.</li>
        <li>Consider using other libraries (e.g., SciPy, Matplotlib) for specialized tasks.</li>
    </ul>

    <h3>Use Case: Scalable Scientific Computing with NumPy, Dask, and Cloud Platforms</h3>
    <p>Suppose we're working on a climate modeling project, requiring massive numerical computations to process large datasets of environmental data. We'll leverage NumPy for core computations, Dask for scalability, and deploy our application on a cloud platform (Google Cloud Run) for efficiency.</p>

    <h3>Project Structure</h3>
    <pre><code>
climate-modeling-project/
│
├── requirements.txt
├── model.py
├── data_loader.py
├── Dockerfile
└── deploy_cloud_run.sh</code></pre>

    <h4>model.py (Utilizing NumPy and Dask)</h4>
    <div class="code-box">
        <pre><code>
import numpy as np
import dask.array as da

def process_environmental_data(data_path):
    # Load data with Dask for scalability
    data = da.from_numpy(np.load(data_path), chunks=(1000, 1000))
    
    # Perform numerical computations with NumPy's API compatibility
    processed_data = (data * 2) + 5
    
    return processed_data.compute()</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h4>deploy_cloud_run.sh (Deployment Script)</h4>
    <div class="code-box">
        <pre><code>
#!/bin/bash

# Build Docker image
docker build -t gcr.io/your-project-id/climate-modeling-image .

# Push image to Google Container Registry
docker push gcr.io/your-project-id/climate-modeling-image

# Deploy on Google Cloud Run
gcloud run deploy --image=gcr.io/your-project-id/climate-modeling-image --platform=managed --region=your-region --allow-unauthenticated</code></pre>
<button class="copy-button"><i class="fas fa-copy"></i></button>
</div>
</section>

<section id="common-errors-troubleshooting">
    <h2 class="seo-friendly-heading">Common Errors and Troubleshooting in NumPy</h2>

    <p>NumPy, while powerful, can sometimes throw errors that hinder your workflow. Here, we'll delve into common issues, provide quick solutions, and outline best practices to help you navigate these challenges efficiently.</p>

    <h3>1. Shape Mismatches</h3>
    <p><strong>Error Description:</strong> Occurs when trying to perform operations on arrays with incompatible shapes.</p>
    <p><strong>Example Error Message:</strong></p>
    <pre><code>ValueError: operands could not be broadcast together with shapes (3,) (4,)</code></pre>

    <h3>Quick Solution:</h3>
    <ul>
        <li><strong>Verify Array Shapes:</strong> Before operations, check <code>array.shape</code> to identify mismatches.</li>
        <li><strong>Reshape or Resize Arrays:</strong> Use <code>np.reshape()</code>, <code>np.resize()</code>, or array slicing to align shapes.</li>
    </ul>

    <h3>Best Practice:</h3>
    <p><strong>Consistent Dimensionality:</strong> Ensure arrays used in the same context have compatible dimensions.</p>

    <h4>Example: Resolving Shape Mismatch</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

# Arrays with shape mismatch
arr1 = np.array([1, 2, 3])  # Shape: (3,)
arr2 = np.array([4, 5, 6, 7])  # Shape: (4,)

# Quick Fix: Reshape arr2 to match arr1's shape
arr2_resized = np.resize(arr2, (3,))  # Now shape is (3,)

# Successful operation
result = arr1 + arr2_resized
print(result)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>2. Dtype Errors</h3>
    <p><strong>Error Description:</strong> Arises when attempting operations between arrays with incompatible data types.</p>
    <p><strong>Example Error Message:</strong></p>
    <pre><code>TypeError: ufunc 'add' did not contain a loop with signature matching types 
(dtype('float64'), dtype('int64')) -> dtype('int64')</code></pre>

    <h3>Quick Solution:</h3>
    <ul>
        <li><strong>Check Dtype:</strong> Verify <code>array.dtype</code> for all involved arrays.</li>
        <li><strong>Explicit Casting:</strong> Use <code>np.astype()</code> or <code>array.astype()</code> to convert dtypes.</li>
    </ul>

    <h3>Best Practice:</h3>
    <p><strong>Unified Dtype:</strong> Maintain consistent data types across arrays in the same operation.</p>

    <h4>Example: Resolving Dtype Error</h4>
    <div class="code-box">
        <pre><code>
import numpy as np

# Arrays with dtype mismatch
arr_float = np.array([1.0, 2.0], dtype=np.float64)  # Dtype: float64
arr_int = np.array([3, 4], dtype=np.int64)  # Dtype: int64

# Quick Fix: Cast arr_int to float64
arr_int_casted = arr_int.astype(np.float64)  # Now dtype is float64

# Successful operation
result = arr_float + arr_int_casted
print(result)</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>3. ValueError</h3>
    <p><strong>Error Description:</strong> Generic error for invalid values, often due to incorrect function arguments.</p>
    <p><strong>Example Error Message:</strong></p>
    <pre><code>ValueError: Invalid value in 'axis' parameter for reduction operation</code></pre>

    <h3>Quick Solution:</h3>
    <ul>
        <li><strong>Review Documentation:</strong> Check the function's documentation for valid arguments.</li>
        <li><strong>Validate Inputs:</strong> Ensure all inputs to NumPy functions are within specified ranges.</li>
    </ul>

    <h3>Best Practice:</h3>
    <p><strong>Defensive Programming:</strong> Anticipate and handle potential invalid inputs gracefully.</p>

    <h4>Example: Handling ValueError in <code>np.random.seed()</code></h4>
    <div class="code-box">
        <pre><code>
import numpy as np

# Incorrect usage
try:
    np.random.seed("invalid_seed")  # Will throw ValueError
except ValueError as e:
    print(f"Error: {e}")

# Correct usage
np.random.seed(42)  # Valid seed</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <p>By applying these quick solutions and adhering to the outlined best practices, you'll efficiently troubleshoot and resolve common errors in your NumPy workflows, ensuring smoother project execution.</p>
</section>

<section id="faqs">
    <h3 class="seo-friendly-heading">Frequently Asked Questions (FAQs) - NumPy</h3>

    <p>Below, we've compiled a list of commonly asked questions about NumPy, along with concise and informative answers to help you better understand and utilize the library.</p>

    <h3>1. What is NumPy, and what is it used for?</h3>
    <p><strong>Answer:</strong> NumPy (Numerical Python) is a library for working with arrays and mathematical operations in Python. It's primarily used for scientific computing, data analysis, and machine learning, providing support for large, multi-dimensional arrays and matrices, along with a wide range of high-performance mathematical functions.</p>

    <h3>2. How do I install NumPy?</h3>
    <p><strong>Answer:</strong></p>
    <ul>
        <li><strong>Using pip (Python's package installer):</strong> Open your terminal/command prompt and run <code>pip install numpy</code>.</li>
        <li><strong>Using conda (if you have Anaconda or Miniconda installed):</strong> Run <code>conda install numpy</code> in your terminal/command prompt.</li>
        <li><strong>Through a Python IDE (Integrated Development Environment):</strong> Many IDEs (e.g., PyCharm, Visual Studio Code) offer package managers where you can search for and install NumPy.</li>
    </ul>

    <h3>3. What is the difference between NumPy arrays and Python lists?</h3>
    <p><strong>Answer:</strong></p>
    <ul>
        <li><strong>NumPy Arrays:</strong>
            <ul>
                <li>Designed for numerical computing.</li>
                <li>All elements must be of the same data type.</li>
                <li>More memory-efficient for large datasets.</li>
                <li>Supports vectorized operations, leading to faster computations.</li>
            </ul>
        </li>
        <li><strong>Python Lists:</strong>
            <ul>
                <li>General-purpose, dynamic collections.</li>
                <li>Can store elements of different data types.</li>
                <li>Less memory-efficient for very large numerical datasets.</li>
                <li>Operations are typically slower due to the lack of vectorization.</li>
            </ul>
        </li>
    </ul>

    <h3>4. How do I perform element-wise operations on NumPy arrays?</h3>
    <p><strong>Answer:</strong> You can perform element-wise operations (e.g., addition, subtraction, multiplication, division) directly on NumPy arrays using the standard mathematical operators (+, -, *, /, etc.). For example:</p>
    <div class="code-box">
        <pre><code>
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

# Element-wise addition
result = arr1 + arr2
print(result)  # Output: [5 7 9]</code></pre>
        <button class="copy-button"><i class="fas fa-copy"></i></button>
    </div>

    <h3>5. Can I use NumPy for data analysis and machine learning?</h3>
    <p><strong>Answer:</strong> Yes, NumPy is a foundational library for both data analysis and machine learning in Python. It provides the basic data structures (e.g., arrays, matrices) and operations (e.g., linear algebra, random number generation) that higher-level libraries like Pandas, SciPy, Scikit-learn, and TensorFlow build upon.</p>

    <h3>6. Is NumPy compatible with other popular Python data science libraries?</h3>
    <p><strong>Answer:</strong> Yes, NumPy is designed to be compatible with other key libraries in the Python data science ecosystem, including:</p>
    <ul>
        <li>Pandas: For data manipulation and analysis.</li>
        <li>Matplotlib and Seaborn: For data visualization.</li>
        <li>Scikit-learn: For machine learning.</li>
        <li>SciPy: For scientific and engineering applications.</li>
    </ul>

    <h3>7. How do I handle missing or NaN (Not a Number) values in NumPy arrays?</h3>
    <p><strong>Answer:</strong></p>
    <ul>
        <li><strong>Detection:</strong> Use <code>np.isnan()</code> to identify NaN values.</li>
        <li><strong>Removal/Replacement:</strong>
            <ul>
                <li><code>np.nanmean()</code>, <code>np.nansum()</code>, etc., ignore NaNs in computations.</li>
                <li>Use <code>np.nan_to_num()</code> to replace NaNs with a specified value (e.g., zero).</li>
                <li>For more complex handling, consider using Pandas, which offers robust missing data management.</li>
            </ul>
        </li>
    </ul>

    <h3>8. Can I use NumPy with Python's asynchronous programming (async/await)?</h3>
    <p><strong>Answer:</strong> While NumPy itself isn't inherently asynchronous, you can use it within asynchronous Python programs. However, since NumPy operations release the Global Interpreter Lock (GIL), they can run in parallel with other Python bytecodes but not truly in parallel with other NumPy operations. For parallel computing, consider libraries like Dask or joblib.</p>
</section>

  </main>
   <footer class="footer">
      <p class="paragraph">Copyright 2023 TechyVia. All rights reserved.</p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <script>
        const MOBILE_BREAKPOINT = 768;
        if (window.innerWidth <= MOBILE_BREAKPOINT) {
          document.write('<script src="mobile.js"><\/script>');
        }
      </script>
      
    
    <script src="script.js"></script>
  </body>
  </html>
  